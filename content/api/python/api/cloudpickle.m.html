<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>heronpy.api.cloudpickle API documentation</title>
    <meta name="description" content="This class is defined to override standard pickle functionality
The goals of it follow:
-Serialize l..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#heronpy.api.cloudpickle.DEFAULT_PROTOCOL">DEFAULT_PROTOCOL</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.DELETE_GLOBAL">DELETE_GLOBAL</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.EXTENDED_ARG">EXTENDED_ARG</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.Final">Final</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.GLOBAL_OPS">GLOBAL_OPS</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.HAVE_ARGUMENT">HAVE_ARGUMENT</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.LOAD_GLOBAL">LOAD_GLOBAL</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.Literal">Literal</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.PYPY">PYPY</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.STORE_GLOBAL">STORE_GLOBAL</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.builtin_code_type">builtin_code_type</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.k">k</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.v">v</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#heronpy.api.cloudpickle.cell_set">cell_set</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.dump">dump</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.dumps">dumps</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.dynamic_subimport">dynamic_subimport</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.instance">instance</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.is_tornado_coroutine">is_tornado_coroutine</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.load">load</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.loads">loads</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.subimport">subimport</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#heronpy.api.cloudpickle.CloudPickler">CloudPickler</a></span>
        
          
  <ul>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.__init__">__init__</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.clear_memo">clear_memo</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.dump">dump</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.extract_func_data">extract_func_data</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.get">get</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.inject_addons">inject_addons</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.memoize">memoize</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.persistent_id">persistent_id</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.put">put</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save">save</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_attrgetter">save_attrgetter</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_bool">save_bool</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_bytes">save_bytes</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_classmethod">save_classmethod</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_codeobject">save_codeobject</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_dict">save_dict</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_dynamic_class">save_dynamic_class</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_ellipsis">save_ellipsis</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_file">save_file</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_float">save_float</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_frozenset">save_frozenset</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_function">save_function</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_function_tuple">save_function_tuple</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_getset_descriptor">save_getset_descriptor</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_global">save_global</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_instancemethod">save_instancemethod</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_itemgetter">save_itemgetter</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_list">save_list</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_logger">save_logger</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_long">save_long</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_mappingproxy">save_mappingproxy</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_memoryview">save_memoryview</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_module">save_module</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_none">save_none</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_not_implemented">save_not_implemented</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_pers">save_pers</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_property">save_property</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_pypy_builtin_func">save_pypy_builtin_func</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_reduce">save_reduce</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_root_logger">save_root_logger</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_set">save_set</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_str">save_str</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_tuple">save_tuple</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_type">save_type</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_typevar">save_typevar</a></li>
    <li class="mono"><a href="#heronpy.api.cloudpickle.CloudPickler.save_weakset">save_weakset</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">heronpy.api.cloudpickle</span> module</h1>
  <p>This class is defined to override standard pickle functionality
The goals of it follow:
-Serialize lambdas and nested functions to compiled byte code
-Deal with main module correctly
-Deal with other non-serializable objects
It does not include an unpickler, as standard python unpickling suffices.
This module was extracted from the <code>cloud</code> package, developed by <code>PiCloud, Inc.
&lt;https://web.archive.org/web/20140626004012/http://www.picloud.com/&gt;</code><em>.
Copyright (c) 2012, Regents of the University of California.
Copyright (c) 2009 <code>PiCloud, Inc. &lt;https://web.archive.org/web/20140626004012/http://www.picloud.com/&gt;</code></em>.
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the University of California, Berkeley nor the
      names of its contributors may be used to endorse or promote
      products derived from this software without specific prior written
      permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle" class="source">
    <pre><code>"""
This class is defined to override standard pickle functionality
The goals of it follow:
-Serialize lambdas and nested functions to compiled byte code
-Deal with main module correctly
-Deal with other non-serializable objects
It does not include an unpickler, as standard python unpickling suffices.
This module was extracted from the `cloud` package, developed by `PiCloud, Inc.
<https://web.archive.org/web/20140626004012/http://www.picloud.com/>`_.
Copyright (c) 2012, Regents of the University of California.
Copyright (c) 2009 `PiCloud, Inc. <https://web.archive.org/web/20140626004012/http://www.picloud.com/>`_.
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the University of California, Berkeley nor the
      names of its contributors may be used to endorse or promote
      products derived from this software without specific prior written
      permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""
# pylint: skip-file
from __future__ import print_function

import abc
import builtins
import dis
import io
import itertools
import logging
import opcode
import operator
import pickle
import platform
import struct
import sys
import types
import weakref
import uuid
import threading
import typing
from enum import Enum

from typing import Generic, Union, Tuple, Callable
from pickle import _Pickler as Pickler
from pickle import _getattribute
from io import BytesIO
from importlib._bootstrap import _find_spec

try:  # pragma: no branch
    import typing_extensions as _typing_extensions
    from typing_extensions import Literal, Final
except ImportError:
    _typing_extensions = Literal = Final = None

if sys.version_info >= (3, 5, 3):
    from typing import ClassVar
else:  # pragma: no cover
    ClassVar = None


# cloudpickle is meant for inter process communication: we expect all
# communicating processes to run the same Python version hence we favor
# communication speed over compatibility:
DEFAULT_PROTOCOL = pickle.HIGHEST_PROTOCOL

# Track the provenance of reconstructed dynamic classes to make it possible to
# recontruct instances from the matching singleton class definition when
# appropriate and preserve the usual "isinstance" semantics of Python objects.
_DYNAMIC_CLASS_TRACKER_BY_CLASS = weakref.WeakKeyDictionary()
_DYNAMIC_CLASS_TRACKER_BY_ID = weakref.WeakValueDictionary()
_DYNAMIC_CLASS_TRACKER_LOCK = threading.Lock()

PYPY = platform.python_implementation() == "PyPy"

builtin_code_type = None
if PYPY:
    # builtin-code objects only exist in pypy
    builtin_code_type = type(float.__new__.__code__)

_extract_code_globals_cache = weakref.WeakKeyDictionary()


def _get_or_create_tracker_id(class_def):
    with _DYNAMIC_CLASS_TRACKER_LOCK:
        class_tracker_id = _DYNAMIC_CLASS_TRACKER_BY_CLASS.get(class_def)
        if class_tracker_id is None:
            class_tracker_id = uuid.uuid4().hex
            _DYNAMIC_CLASS_TRACKER_BY_CLASS[class_def] = class_tracker_id
            _DYNAMIC_CLASS_TRACKER_BY_ID[class_tracker_id] = class_def
    return class_tracker_id


def _lookup_class_or_track(class_tracker_id, class_def):
    if class_tracker_id is not None:
        with _DYNAMIC_CLASS_TRACKER_LOCK:
            class_def = _DYNAMIC_CLASS_TRACKER_BY_ID.setdefault(
                class_tracker_id, class_def)
            _DYNAMIC_CLASS_TRACKER_BY_CLASS[class_def] = class_tracker_id
    return class_def


def _whichmodule(obj, name):
    """Find the module an object belongs to.
    This function differs from ``pickle.whichmodule`` in two ways:
    - it does not mangle the cases where obj's module is __main__ and obj was
      not found in any module.
    - Errors arising during module introspection are ignored, as those errors
      are considered unwanted side effects.
    """
    if sys.version_info[:2] < (3, 7) and isinstance(obj, typing.TypeVar):  # pragma: no branch  # noqa
        # Workaround bug in old Python versions: prior to Python 3.7,
        # T.__module__ would always be set to "typing" even when the TypeVar T
        # would be defined in a different module.
        #
        # For such older Python versions, we ignore the __module__ attribute of
        # TypeVar instances and instead exhaustively lookup those instances in
        # all currently imported modules.
        module_name = None
    else:
        module_name = getattr(obj, '__module__', None)

    if module_name is not None:
        return module_name
    # Protect the iteration by using a copy of sys.modules against dynamic
    # modules that trigger imports of other modules upon calls to getattr or
    # other threads importing at the same time.
    for module_name, module in sys.modules.copy().items():
        # Some modules such as coverage can inject non-module objects inside
        # sys.modules
        if (
                module_name == '__main__' or
                module is None or
                not isinstance(module, types.ModuleType)
        ):
            continue
        try:
            if _getattribute(module, name)[0] is obj:
                return module_name
        except Exception:
            pass
    return None


def _is_importable_by_name(obj, name=None):
    """Determine if obj can be pickled as attribute of a file-backed module"""
    return _lookup_module_and_qualname(obj, name=name) is not None


def _lookup_module_and_qualname(obj, name=None):
    if name is None:
        name = getattr(obj, '__qualname__', None)
    if name is None:  # pragma: no cover
        # This used to be needed for Python 2.7 support but is probably not
        # needed anymore. However we keep the __name__ introspection in case
        # users of cloudpickle rely on this old behavior for unknown reasons.
        name = getattr(obj, '__name__', None)

    module_name = _whichmodule(obj, name)

    if module_name is None:
        # In this case, obj.__module__ is None AND obj was not found in any
        # imported module. obj is thus treated as dynamic.
        return None

    if module_name == "__main__":
        return None

    module = sys.modules.get(module_name, None)
    if module is None:
        # The main reason why obj's module would not be imported is that this
        # module has been dynamically created, using for example
        # types.ModuleType. The other possibility is that module was removed
        # from sys.modules after obj was created/imported. But this case is not
        # supported, as the standard pickle does not support it either.
        return None

    # module has been added to sys.modules, but it can still be dynamic.
    if _is_dynamic(module):
        return None

    try:
        obj2, parent = _getattribute(module, name)
    except AttributeError:
        # obj was not found inside the module it points to
        return None
    if obj2 is not obj:
        return None
    return module, name


def _extract_code_globals(co):
    """
    Find all globals names read or written to by codeblock co
    """
    out_names = _extract_code_globals_cache.get(co)
    if out_names is None:
        names = co.co_names
        out_names = {names[oparg] for _, oparg in _walk_global_ops(co)}

        # Declaring a function inside another one using the "def ..."
        # syntax generates a constant code object corresonding to the one
        # of the nested function's As the nested function may itself need
        # global variables, we need to introspect its code, extract its
        # globals, (look for code object in it's co_consts attribute..) and
        # add the result to code_globals
        if co.co_consts:
            for const in co.co_consts:
                if isinstance(const, types.CodeType):
                    out_names |= _extract_code_globals(const)

        _extract_code_globals_cache[co] = out_names

    return out_names


def _find_imported_submodules(code, top_level_dependencies):
    """
    Find currently imported submodules used by a function.
    Submodules used by a function need to be detected and referenced for the
    function to work correctly at depickling time. Because submodules can be
    referenced as attribute of their parent package (``package.submodule``), we
    need a special introspection technique that does not rely on GLOBAL-related
    opcodes to find references of them in a code object.
    Example:
    ```
    import concurrent.futures
    import cloudpickle
    def func():
        x = concurrent.futures.ThreadPoolExecutor
    if __name__ == '__main__':
        cloudpickle.dumps(func)
    ```
    The globals extracted by cloudpickle in the function's state include the
    concurrent package, but not its submodule (here, concurrent.futures), which
    is the module used by func. Find_imported_submodules will detect the usage
    of concurrent.futures. Saving this module alongside with func will ensure
    that calling func once depickled does not fail due to concurrent.futures
    not being imported
    """

    subimports = []
    # check if any known dependency is an imported package
    for x in top_level_dependencies:
        if (isinstance(x, types.ModuleType) and
                hasattr(x, '__package__') and x.__package__):
            # check if the package has any currently loaded sub-imports
            prefix = x.__name__ + '.'
            # A concurrent thread could mutate sys.modules,
            # make sure we iterate over a copy to avoid exceptions
            for name in list(sys.modules):
                # Older versions of pytest will add a "None" module to
                # sys.modules.
                if name is not None and name.startswith(prefix):
                    # check whether the function can address the sub-module
                    tokens = set(name[len(prefix):].split('.'))
                    if not tokens - set(code.co_names):
                        subimports.append(sys.modules[name])
    return subimports


def cell_set(cell, value):
    """Set the value of a closure cell.
    The point of this function is to set the cell_contents attribute of a cell
    after its creation. This operation is necessary in case the cell contains a
    reference to the function the cell belongs to, as when calling the
    function's constructor
    ``f = types.FunctionType(code, globals, name, argdefs, closure)``,
    closure will not be able to contain the yet-to-be-created f.
    In Python3.7, cell_contents is writeable, so setting the contents of a cell
    can be done simply using
    >>> cell.cell_contents = value
    In earlier Python3 versions, the cell_contents attribute of a cell is read
    only, but this limitation can be worked around by leveraging the Python 3
    ``nonlocal`` keyword.
    In Python2 however, this attribute is read only, and there is no
    ``nonlocal`` keyword. For this reason, we need to come up with more
    complicated hacks to set this attribute.
    The chosen approach is to create a function with a STORE_DEREF opcode,
    which sets the content of a closure variable. Typically:
    >>> def inner(value):
    ...     lambda: cell  # the lambda makes cell a closure
    ...     cell = value  # cell is a closure, so this triggers a STORE_DEREF
    (Note that in Python2, A STORE_DEREF can never be triggered from an inner
    function. The function g for example here
    >>> def f(var):
    ...     def g():
    ...         var += 1
    ...     return g
    will not modify the closure variable ``var```inplace, but instead try to
    load a local variable var and increment it. As g does not assign the local
    variable ``var`` any initial value, calling f(1)() will fail at runtime.)
    Our objective is to set the value of a given cell ``cell``. So we need to
    somewhat reference our ``cell`` object into the ``inner`` function so that
    this object (and not the smoke cell of the lambda function) gets affected
    by the STORE_DEREF operation.
    In inner, ``cell`` is referenced as a cell variable (an enclosing variable
    that is referenced by the inner function). If we create a new function
    cell_set with the exact same code as ``inner``, but with ``cell`` marked as
    a free variable instead, the STORE_DEREF will be applied on its closure -
    ``cell``, which we can specify explicitly during construction! The new
    cell_set variable thus actually sets the contents of a specified cell!
    Note: we do not make use of the ``nonlocal`` keyword to set the contents of
    a cell in early python3 versions to limit possible syntax errors in case
    test and checker libraries decide to parse the whole file.
    """

    if sys.version_info[:2] >= (3, 7):  # pragma: no branch
        cell.cell_contents = value
    else:
        _cell_set = types.FunctionType(
            _cell_set_template_code, {}, '_cell_set', (), (cell,),)
        _cell_set(value)


def _make_cell_set_template_code():
    def _cell_set_factory(value):
        lambda: cell
        cell = value

    co = _cell_set_factory.__code__

    _cell_set_template_code = types.CodeType(
        co.co_argcount,
        co.co_kwonlyargcount,   # Python 3 only argument
        co.co_nlocals,
        co.co_stacksize,
        co.co_flags,
        co.co_code,
        co.co_consts,
        co.co_names,
        co.co_varnames,
        co.co_filename,
        co.co_name,
        co.co_firstlineno,
        co.co_lnotab,
        co.co_cellvars,  # co_freevars is initialized with co_cellvars
        (),  # co_cellvars is made empty
    )
    return _cell_set_template_code


if sys.version_info[:2] < (3, 7):
    _cell_set_template_code = _make_cell_set_template_code()

# relevant opcodes
STORE_GLOBAL = opcode.opmap['STORE_GLOBAL']
DELETE_GLOBAL = opcode.opmap['DELETE_GLOBAL']
LOAD_GLOBAL = opcode.opmap['LOAD_GLOBAL']
GLOBAL_OPS = (STORE_GLOBAL, DELETE_GLOBAL, LOAD_GLOBAL)
HAVE_ARGUMENT = dis.HAVE_ARGUMENT
EXTENDED_ARG = dis.EXTENDED_ARG


_BUILTIN_TYPE_NAMES = {}
for k, v in types.__dict__.items():
    if type(v) is type:
        _BUILTIN_TYPE_NAMES[v] = k


def _builtin_type(name):
    if name == "ClassType":  # pragma: no cover
        # Backward compat to load pickle files generated with cloudpickle
        # < 1.3 even if loading pickle files from older versions is not
        # officially supported.
        return type
    return getattr(types, name)


def _walk_global_ops(code):
    """
    Yield (opcode, argument number) tuples for all
    global-referencing instructions in *code*.
    """
    for instr in dis.get_instructions(code):
        op = instr.opcode
        if op in GLOBAL_OPS:
            yield op, instr.arg


def _extract_class_dict(cls):
    """Retrieve a copy of the dict of a class without the inherited methods"""
    clsdict = dict(cls.__dict__)  # copy dict proxy to a dict
    if len(cls.__bases__) == 1:
        inherited_dict = cls.__bases__[0].__dict__
    else:
        inherited_dict = {}
        for base in reversed(cls.__bases__):
            inherited_dict.update(base.__dict__)
    to_remove = []
    for name, value in clsdict.items():
        try:
            base_value = inherited_dict[name]
            if value is base_value:
                to_remove.append(name)
        except KeyError:
            pass
    for name in to_remove:
        clsdict.pop(name)
    return clsdict


if sys.version_info[:2] < (3, 7):  # pragma: no branch
    def _is_parametrized_type_hint(obj):
        # This is very cheap but might generate false positives.
        # general typing Constructs
        is_typing = getattr(obj, '__origin__', None) is not None

        # typing_extensions.Literal
        is_litteral = getattr(obj, '__values__', None) is not None

        # typing_extensions.Final
        is_final = getattr(obj, '__type__', None) is not None

        # typing.Union/Tuple for old Python 3.5
        is_union = getattr(obj, '__union_params__', None) is not None
        is_tuple = getattr(obj, '__tuple_params__', None) is not None
        is_callable = (
            getattr(obj, '__result__', None) is not None and
            getattr(obj, '__args__', None) is not None
        )
        return any((is_typing, is_litteral, is_final, is_union, is_tuple,
                    is_callable))

    def _create_parametrized_type_hint(origin, args):
        return origin[args]


class CloudPickler(Pickler):

    dispatch = Pickler.dispatch.copy()

    def __init__(self, file, protocol=None):
        if protocol is None:
            protocol = DEFAULT_PROTOCOL
        Pickler.__init__(self, file, protocol=protocol)
        # map ids to dictionary. used to ensure that functions can share global env
        self.globals_ref = {}

    def dump(self, obj):
        self.inject_addons()
        try:
            return Pickler.dump(self, obj)
        except RuntimeError as e:
            if 'recursion' in e.args[0]:
                msg = """Could not pickle object as excessively deep recursion required."""
                raise pickle.PicklingError(msg)
            else:
                raise

    def save_typevar(self, obj):
        self.save_reduce(*_typevar_reduce(obj), obj=obj)

    dispatch[typing.TypeVar] = save_typevar

    def save_memoryview(self, obj):
        self.save(obj.tobytes())

    dispatch[memoryview] = save_memoryview

    def save_module(self, obj):
        """
        Save a module as an import
        """
        if _is_dynamic(obj):
            obj.__dict__.pop('__builtins__', None)
            self.save_reduce(dynamic_subimport, (obj.__name__, vars(obj)),
                             obj=obj)
        else:
            self.save_reduce(subimport, (obj.__name__,), obj=obj)

    dispatch[types.ModuleType] = save_module

    def save_codeobject(self, obj):
        """
        Save a code object
        """
        if hasattr(obj, "co_posonlyargcount"):  # pragma: no branch
            args = (
                obj.co_argcount, obj.co_posonlyargcount,
                obj.co_kwonlyargcount, obj.co_nlocals, obj.co_stacksize,
                obj.co_flags, obj.co_code, obj.co_consts, obj.co_names,
                obj.co_varnames, obj.co_filename, obj.co_name,
                obj.co_firstlineno, obj.co_lnotab, obj.co_freevars,
                obj.co_cellvars
            )
        else:
            args = (
                obj.co_argcount, obj.co_kwonlyargcount, obj.co_nlocals,
                obj.co_stacksize, obj.co_flags, obj.co_code, obj.co_consts,
                obj.co_names, obj.co_varnames, obj.co_filename,
                obj.co_name, obj.co_firstlineno, obj.co_lnotab,
                obj.co_freevars, obj.co_cellvars
            )
        self.save_reduce(types.CodeType, args, obj=obj)

    dispatch[types.CodeType] = save_codeobject

    def save_function(self, obj, name=None):
        """ Registered with the dispatch to handle all function types.
        Determines what kind of function obj is (e.g. lambda, defined at
        interactive prompt, etc) and handles the pickling appropriately.
        """
        if _is_importable_by_name(obj, name=name):
            return Pickler.save_global(self, obj, name=name)
        elif PYPY and isinstance(obj.__code__, builtin_code_type):
            return self.save_pypy_builtin_func(obj)
        else:
            return self.save_function_tuple(obj)

    dispatch[types.FunctionType] = save_function

    def save_pypy_builtin_func(self, obj):
        """Save pypy equivalent of builtin functions.
        PyPy does not have the concept of builtin-functions. Instead,
        builtin-functions are simple function instances, but with a
        builtin-code attribute.
        Most of the time, builtin functions should be pickled by attribute. But
        PyPy has flaky support for __qualname__, so some builtin functions such
        as float.__new__ will be classified as dynamic. For this reason only,
        we created this special routine. Because builtin-functions are not
        expected to have closure or globals, there is no additional hack
        (compared the one already implemented in pickle) to protect ourselves
        from reference cycles. A simple (reconstructor, newargs, obj.__dict__)
        tuple is save_reduced.
        Note also that PyPy improved their support for __qualname__ in v3.6, so
        this routing should be removed when cloudpickle supports only PyPy 3.6
        and later.
        """
        rv = (types.FunctionType, (obj.__code__, {}, obj.__name__,
                                   obj.__defaults__, obj.__closure__),
              obj.__dict__)
        self.save_reduce(*rv, obj=obj)

    def _save_dynamic_enum(self, obj, clsdict):
        """Special handling for dynamic Enum subclasses
        Use a dedicated Enum constructor (inspired by EnumMeta.__call__) as the
        EnumMeta metaclass has complex initialization that makes the Enum
        subclasses hold references to their own instances.
        """
        members = dict((e.name, e.value) for e in obj)

        self.save_reduce(
                _make_skeleton_enum,
                (obj.__bases__, obj.__name__, obj.__qualname__,
                 members, obj.__module__, _get_or_create_tracker_id(obj), None),
                obj=obj
         )

        # Cleanup the clsdict that will be passed to _rehydrate_skeleton_class:
        # Those attributes are already handled by the metaclass.
        for attrname in ["_generate_next_value_", "_member_names_",
                         "_member_map_", "_member_type_",
                         "_value2member_map_"]:
            clsdict.pop(attrname, None)
        for member in members:
            clsdict.pop(member)

    def save_dynamic_class(self, obj):
        """Save a class that can't be stored as module global.
        This method is used to serialize classes that are defined inside
        functions, or that otherwise can't be serialized as attribute lookups
        from global modules.
        """
        clsdict = _extract_class_dict(obj)
        clsdict.pop('__weakref__', None)

        if issubclass(type(obj), abc.ABCMeta):
            # If obj is an instance of an ABCMeta subclass, dont pickle the
            # cache/negative caches populated during isinstance/issubclass
            # checks, but pickle the list of registered subclasses of obj.
            clsdict.pop('_abc_cache', None)
            clsdict.pop('_abc_negative_cache', None)
            clsdict.pop('_abc_negative_cache_version', None)
            registry = clsdict.pop('_abc_registry', None)
            if registry is None:
                # in Python3.7+, the abc caches and registered subclasses of a
                # class are bundled into the single _abc_impl attribute
                clsdict.pop('_abc_impl', None)
                (registry, _, _, _) = abc._get_dump(obj)

                clsdict["_abc_impl"] = [subclass_weakref()
                                        for subclass_weakref in registry]
            else:
                # In the above if clause, registry is a set of weakrefs -- in
                # this case, registry is a WeakSet
                clsdict["_abc_impl"] = [type_ for type_ in registry]

        # On PyPy, __doc__ is a readonly attribute, so we need to include it in
        # the initial skeleton class.  This is safe because we know that the
        # doc can't participate in a cycle with the original class.
        type_kwargs = {'__doc__': clsdict.pop('__doc__', None)}

        if "__slots__" in clsdict:
            type_kwargs['__slots__'] = obj.__slots__
            # pickle string length optimization: member descriptors of obj are
            # created automatically from obj's __slots__ attribute, no need to
            # save them in obj's state
            if isinstance(obj.__slots__, str):
                clsdict.pop(obj.__slots__)
            else:
                for k in obj.__slots__:
                    clsdict.pop(k, None)

        # If type overrides __dict__ as a property, include it in the type
        # kwargs. In Python 2, we can't set this attribute after construction.
        # XXX: can this ever happen in Python 3? If so add a test.
        __dict__ = clsdict.pop('__dict__', None)
        if isinstance(__dict__, property):
            type_kwargs['__dict__'] = __dict__

        save = self.save
        write = self.write

        # We write pickle instructions explicitly here to handle the
        # possibility that the type object participates in a cycle with its own
        # __dict__. We first write an empty "skeleton" version of the class and
        # memoize it before writing the class' __dict__ itself. We then write
        # instructions to "rehydrate" the skeleton class by restoring the
        # attributes from the __dict__.
        #
        # A type can appear in a cycle with its __dict__ if an instance of the
        # type appears in the type's __dict__ (which happens for the stdlib
        # Enum class), or if the type defines methods that close over the name
        # of the type, (which is common for Python 2-style super() calls).

        # Push the rehydration function.
        save(_rehydrate_skeleton_class)

        # Mark the start of the args tuple for the rehydration function.
        write(pickle.MARK)

        # Create and memoize an skeleton class with obj's name and bases.
        if Enum is not None and issubclass(obj, Enum):
            # Special handling of Enum subclasses
            self._save_dynamic_enum(obj, clsdict)
        else:
            # "Regular" class definition:
            tp = type(obj)
            self.save_reduce(_make_skeleton_class,
                             (tp, obj.__name__, _get_bases(obj), type_kwargs,
                              _get_or_create_tracker_id(obj), None),
                             obj=obj)

        # Now save the rest of obj's __dict__. Any references to obj
        # encountered while saving will point to the skeleton class.
        save(clsdict)

        # Write a tuple of (skeleton_class, clsdict).
        write(pickle.TUPLE)

        # Call _rehydrate_skeleton_class(skeleton_class, clsdict)
        write(pickle.REDUCE)

    def save_function_tuple(self, func):
        """  Pickles an actual func object.
        A func comprises: code, globals, defaults, closure, and dict.  We
        extract and save these, injecting reducing functions at certain points
        to recreate the func object.  Keep in mind that some of these pieces
        can contain a ref to the func itself.  Thus, a naive save on these
        pieces could trigger an infinite loop of save's.  To get around that,
        we first create a skeleton func object using just the code (this is
        safe, since this won't contain a ref to the func), and memoize it as
        soon as it's created.  The other stuff can then be filled in later.
        """
        if is_tornado_coroutine(func):
            self.save_reduce(_rebuild_tornado_coroutine, (func.__wrapped__,),
                             obj=func)
            return

        save = self.save
        write = self.write

        code, f_globals, defaults, closure_values, dct, base_globals = self.extract_func_data(func)

        save(_fill_function)  # skeleton function updater
        write(pickle.MARK)    # beginning of tuple that _fill_function expects

        # Extract currently-imported submodules used by func. Storing these
        # modules in a smoke _cloudpickle_subimports attribute of the object's
        # state will trigger the side effect of importing these modules at
        # unpickling time (which is necessary for func to work correctly once
        # depickled)
        submodules = _find_imported_submodules(
            code,
            itertools.chain(f_globals.values(), closure_values or ()),
        )

        # create a skeleton function object and memoize it
        save(_make_skel_func)
        save((
            code,
            len(closure_values) if closure_values is not None else -1,
            base_globals,
        ))
        write(pickle.REDUCE)
        self.memoize(func)

        # save the rest of the func data needed by _fill_function
        state = {
            'globals': f_globals,
            'defaults': defaults,
            'dict': dct,
            'closure_values': closure_values,
            'module': func.__module__,
            'name': func.__name__,
            'doc': func.__doc__,
            '_cloudpickle_submodules': submodules
        }
        if hasattr(func, '__annotations__'):
            state['annotations'] = func.__annotations__
        if hasattr(func, '__qualname__'):
            state['qualname'] = func.__qualname__
        if hasattr(func, '__kwdefaults__'):
            state['kwdefaults'] = func.__kwdefaults__
        save(state)
        write(pickle.TUPLE)
        write(pickle.REDUCE)  # applies _fill_function on the tuple

    def extract_func_data(self, func):
        """
        Turn the function into a tuple of data necessary to recreate it:
            code, globals, defaults, closure_values, dict
        """
        code = func.__code__

        # extract all global ref's
        func_global_refs = _extract_code_globals(code)

        # process all variables referenced by global environment
        f_globals = {}
        for var in func_global_refs:
            if var in func.__globals__:
                f_globals[var] = func.__globals__[var]

        # defaults requires no processing
        defaults = func.__defaults__

        # process closure
        closure = (
            list(map(_get_cell_contents, func.__closure__))
            if func.__closure__ is not None
            else None
        )

        # save the dict
        dct = func.__dict__

        # base_globals represents the future global namespace of func at
        # unpickling time. Looking it up and storing it in globals_ref allow
        # functions sharing the same globals at pickling time to also
        # share them once unpickled, at one condition: since globals_ref is
        # an attribute of a Cloudpickler instance, and that a new CloudPickler is
        # created each time pickle.dump or pickle.dumps is called, functions
        # also need to be saved within the same invokation of
        # cloudpickle.dump/cloudpickle.dumps (for example: cloudpickle.dumps([f1, f2])). There
        # is no such limitation when using Cloudpickler.dump, as long as the
        # multiple invokations are bound to the same Cloudpickler.
        base_globals = self.globals_ref.setdefault(id(func.__globals__), {})

        if base_globals == {}:
            # Add module attributes used to resolve relative imports
            # instructions inside func.
            for k in ["__package__", "__name__", "__path__", "__file__"]:
                # Some built-in functions/methods such as object.__new__  have
                # their __globals__ set to None in PyPy
                if func.__globals__ is not None and k in func.__globals__:
                    base_globals[k] = func.__globals__[k]

        return (code, f_globals, defaults, closure, dct, base_globals)

    def save_getset_descriptor(self, obj):
        return self.save_reduce(getattr, (obj.__objclass__, obj.__name__))

    dispatch[types.GetSetDescriptorType] = save_getset_descriptor

    def save_global(self, obj, name=None, pack=struct.pack):
        """
        Save a "global".
        The name of this method is somewhat misleading: all types get
        dispatched here.
        """
        if obj is type(None):
            return self.save_reduce(type, (None,), obj=obj)
        elif obj is type(Ellipsis):
            return self.save_reduce(type, (Ellipsis,), obj=obj)
        elif obj is type(NotImplemented):
            return self.save_reduce(type, (NotImplemented,), obj=obj)
        elif obj in _BUILTIN_TYPE_NAMES:
            return self.save_reduce(
                _builtin_type, (_BUILTIN_TYPE_NAMES[obj],), obj=obj)

        if sys.version_info[:2] < (3, 7) and _is_parametrized_type_hint(obj):  # noqa  # pragma: no branch
            # Parametrized typing constructs in Python < 3.7 are not compatible
            # with type checks and ``isinstance`` semantics. For this reason,
            # it is easier to detect them using a duck-typing-based check
            # (``_is_parametrized_type_hint``) than to populate the Pickler's
            # dispatch with type-specific savers.
            self._save_parametrized_type_hint(obj)
        elif name is not None:
            Pickler.save_global(self, obj, name=name)
        elif not _is_importable_by_name(obj, name=name):
            self.save_dynamic_class(obj)
        else:
            Pickler.save_global(self, obj, name=name)

    dispatch[type] = save_global

    def save_instancemethod(self, obj):
        # Memoization rarely is ever useful due to python bounding
        if obj.__self__ is None:
            self.save_reduce(getattr, (obj.im_class, obj.__name__))
        else:
            self.save_reduce(types.MethodType, (obj.__func__, obj.__self__), obj=obj)

    dispatch[types.MethodType] = save_instancemethod

    def save_property(self, obj):
        # properties not correctly saved in python
        self.save_reduce(property, (obj.fget, obj.fset, obj.fdel, obj.__doc__),
                         obj=obj)

    dispatch[property] = save_property

    def save_classmethod(self, obj):
        orig_func = obj.__func__
        self.save_reduce(type(obj), (orig_func,), obj=obj)

    dispatch[classmethod] = save_classmethod
    dispatch[staticmethod] = save_classmethod

    def save_itemgetter(self, obj):
        """itemgetter serializer (needed for namedtuple support)"""
        class Dummy:
            def __getitem__(self, item):
                return item
        items = obj(Dummy())
        if not isinstance(items, tuple):
            items = (items,)
        return self.save_reduce(operator.itemgetter, items)

    if type(operator.itemgetter) is type:
        dispatch[operator.itemgetter] = save_itemgetter

    def save_attrgetter(self, obj):
        """attrgetter serializer"""
        class Dummy(object):
            def __init__(self, attrs, index=None):
                self.attrs = attrs
                self.index = index
            def __getattribute__(self, item):
                attrs = object.__getattribute__(self, "attrs")
                index = object.__getattribute__(self, "index")
                if index is None:
                    index = len(attrs)
                    attrs.append(item)
                else:
                    attrs[index] = ".".join([attrs[index], item])
                return type(self)(attrs, index)
        attrs = []
        obj(Dummy(attrs))
        return self.save_reduce(operator.attrgetter, tuple(attrs))

    if type(operator.attrgetter) is type:
        dispatch[operator.attrgetter] = save_attrgetter

    def save_file(self, obj):
        """Save a file"""

        if not hasattr(obj, 'name') or not hasattr(obj, 'mode'):
            raise pickle.PicklingError("Cannot pickle files that do not map to an actual file")
        if obj is sys.stdout:
            return self.save_reduce(getattr, (sys, 'stdout'), obj=obj)
        if obj is sys.stderr:
            return self.save_reduce(getattr, (sys, 'stderr'), obj=obj)
        if obj is sys.stdin:
            raise pickle.PicklingError("Cannot pickle standard input")
        if obj.closed:
            raise pickle.PicklingError("Cannot pickle closed files")
        if hasattr(obj, 'isatty') and obj.isatty():
            raise pickle.PicklingError("Cannot pickle files that map to tty objects")
        if 'r' not in obj.mode and '+' not in obj.mode:
            raise pickle.PicklingError("Cannot pickle files that are not opened for reading: %s" % obj.mode)

        name = obj.name

        # TODO: also support binary mode files with io.BytesIO
        retval = io.StringIO()

        try:
            # Read the whole file
            curloc = obj.tell()
            obj.seek(0)
            contents = obj.read()
            obj.seek(curloc)
        except IOError:
            raise pickle.PicklingError("Cannot pickle file %s as it cannot be read" % name)
        retval.write(contents)
        retval.seek(curloc)

        retval.name = name
        self.save(retval)
        self.memoize(obj)

    def save_ellipsis(self, obj):
        self.save_reduce(_gen_ellipsis, ())

    def save_not_implemented(self, obj):
        self.save_reduce(_gen_not_implemented, ())

    dispatch[io.TextIOWrapper] = save_file
    dispatch[type(Ellipsis)] = save_ellipsis
    dispatch[type(NotImplemented)] = save_not_implemented

    def save_weakset(self, obj):
        self.save_reduce(weakref.WeakSet, (list(obj),))

    dispatch[weakref.WeakSet] = save_weakset

    def save_logger(self, obj):
        self.save_reduce(logging.getLogger, (obj.name,), obj=obj)

    dispatch[logging.Logger] = save_logger

    def save_root_logger(self, obj):
        self.save_reduce(logging.getLogger, (), obj=obj)

    dispatch[logging.RootLogger] = save_root_logger

    if hasattr(types, "MappingProxyType"):  # pragma: no branch
        def save_mappingproxy(self, obj):
            self.save_reduce(types.MappingProxyType, (dict(obj),), obj=obj)

        dispatch[types.MappingProxyType] = save_mappingproxy

    """Special functions for Add-on libraries"""
    def inject_addons(self):
        """Plug in system. Register additional pickling functions if modules already loaded"""
        pass

    if sys.version_info < (3, 7):  # pragma: no branch
        def _save_parametrized_type_hint(self, obj):
            # The distorted type check sematic for typing construct becomes:
            # ``type(obj) is type(TypeHint)``, which means "obj is a
            # parametrized TypeHint"
            if type(obj) is type(Literal):  # pragma: no branch
                initargs = (Literal, obj.__values__)
            elif type(obj) is type(Final):  # pragma: no branch
                initargs = (Final, obj.__type__)
            elif type(obj) is type(ClassVar):
                initargs = (ClassVar, obj.__type__)
            elif type(obj) is type(Generic):
                parameters = obj.__parameters__
                if len(obj.__parameters__) > 0:
                    # in early Python 3.5, __parameters__ was sometimes
                    # preferred to __args__
                    initargs = (obj.__origin__, parameters)
                else:
                    initargs = (obj.__origin__, obj.__args__)
            elif type(obj) is type(Union):
                if sys.version_info < (3, 5, 3):  # pragma: no cover
                    initargs = (Union, obj.__union_params__)
                else:
                    initargs = (Union, obj.__args__)
            elif type(obj) is type(Tuple):
                if sys.version_info < (3, 5, 3):  # pragma: no cover
                    initargs = (Tuple, obj.__tuple_params__)
                else:
                    initargs = (Tuple, obj.__args__)
            elif type(obj) is type(Callable):
                if sys.version_info < (3, 5, 3):  # pragma: no cover
                    args = obj.__args__
                    result = obj.__result__
                    if args != Ellipsis:
                        if isinstance(args, tuple):
                            args = list(args)
                        else:
                            args = [args]
                else:
                    (*args, result) = obj.__args__
                    if len(args) == 1 and args[0] is Ellipsis:
                        args = Ellipsis
                    else:
                        args = list(args)
                initargs = (Callable, (args, result))
            else:  # pragma: no cover
                raise pickle.PicklingError(
                    "Cloudpickle Error: Unknown type {}".format(type(obj))
                )
            self.save_reduce(_create_parametrized_type_hint, initargs, obj=obj)


# Tornado support

def is_tornado_coroutine(func):
    """
    Return whether *func* is a Tornado coroutine function.
    Running coroutines are not supported.
    """
    if 'tornado.gen' not in sys.modules:
        return False
    gen = sys.modules['tornado.gen']
    if not hasattr(gen, "is_coroutine_function"):
        # Tornado version is too old
        return False
    return gen.is_coroutine_function(func)


def _rebuild_tornado_coroutine(func):
    from tornado import gen
    return gen.coroutine(func)


# Shorthands for legacy support

def dump(obj, file, protocol=None):
    """Serialize obj as bytes streamed into file
    protocol defaults to cloudpickle.DEFAULT_PROTOCOL which is an alias to
    pickle.HIGHEST_PROTOCOL. This setting favors maximum communication speed
    between processes running the same Python version.
    Set protocol=pickle.DEFAULT_PROTOCOL instead if you need to ensure
    compatibility with older versions of Python.
    """
    CloudPickler(file, protocol=protocol).dump(obj)


def dumps(obj, protocol=None):
    """Serialize obj as a string of bytes allocated in memory
    protocol defaults to cloudpickle.DEFAULT_PROTOCOL which is an alias to
    pickle.HIGHEST_PROTOCOL. This setting favors maximum communication speed
    between processes running the same Python version.
    Set protocol=pickle.DEFAULT_PROTOCOL instead if you need to ensure
    compatibility with older versions of Python.
    """
    file = BytesIO()
    try:
        cp = CloudPickler(file, protocol=protocol)
        cp.dump(obj)
        return file.getvalue()
    finally:
        file.close()


# including pickles unloading functions in this namespace
load = pickle.load
loads = pickle.loads


# hack for __import__ not working as desired
def subimport(name):
    __import__(name)
    return sys.modules[name]


def dynamic_subimport(name, vars):
    mod = types.ModuleType(name)
    mod.__dict__.update(vars)
    mod.__dict__['__builtins__'] = builtins.__dict__
    return mod


def _gen_ellipsis():
    return Ellipsis


def _gen_not_implemented():
    return NotImplemented


def _get_cell_contents(cell):
    try:
        return cell.cell_contents
    except ValueError:
        # sentinel used by ``_fill_function`` which will leave the cell empty
        return _empty_cell_value


def instance(cls):
    """Create a new instance of a class.
    Parameters
    ----------
    cls : type
        The class to create an instance of.
    Returns
    -------
    instance : cls
        A new instance of ``cls``.
    """
    return cls()


@instance
class _empty_cell_value(object):
    """sentinel for empty closures
    """
    @classmethod
    def __reduce__(cls):
        return cls.__name__


def _fill_function(*args):
    """Fills in the rest of function data into the skeleton function object
    The skeleton itself is create by _make_skel_func().
    """
    if len(args) == 2:
        func = args[0]
        state = args[1]
    elif len(args) == 5:
        # Backwards compat for cloudpickle v0.4.0, after which the `module`
        # argument was introduced
        func = args[0]
        keys = ['globals', 'defaults', 'dict', 'closure_values']
        state = dict(zip(keys, args[1:]))
    elif len(args) == 6:
        # Backwards compat for cloudpickle v0.4.1, after which the function
        # state was passed as a dict to the _fill_function it-self.
        func = args[0]
        keys = ['globals', 'defaults', 'dict', 'module', 'closure_values']
        state = dict(zip(keys, args[1:]))
    else:
        raise ValueError('Unexpected _fill_value arguments: %r' % (args,))

    # - At pickling time, any dynamic global variable used by func is
    #   serialized by value (in state['globals']).
    # - At unpickling time, func's __globals__ attribute is initialized by
    #   first retrieving an empty isolated namespace that will be shared
    #   with other functions pickled from the same original module
    #   by the same CloudPickler instance and then updated with the
    #   content of state['globals'] to populate the shared isolated
    #   namespace with all the global variables that are specifically
    #   referenced for this function.
    func.__globals__.update(state['globals'])

    func.__defaults__ = state['defaults']
    func.__dict__ = state['dict']
    if 'annotations' in state:
        func.__annotations__ = state['annotations']
    if 'doc' in state:
        func.__doc__  = state['doc']
    if 'name' in state:
        func.__name__ = state['name']
    if 'module' in state:
        func.__module__ = state['module']
    if 'qualname' in state:
        func.__qualname__ = state['qualname']
    if 'kwdefaults' in state:
        func.__kwdefaults__ = state['kwdefaults']
    # _cloudpickle_subimports is a set of submodules that must be loaded for
    # the pickled function to work correctly at unpickling time. Now that these
    # submodules are depickled (hence imported), they can be removed from the
    # object's state (the object state only served as a reference holder to
    # these submodules)
    if '_cloudpickle_submodules' in state:
        state.pop('_cloudpickle_submodules')

    cells = func.__closure__
    if cells is not None:
        for cell, value in zip(cells, state['closure_values']):
            if value is not _empty_cell_value:
                cell_set(cell, value)

    return func


def _make_empty_cell():
    if False:
        # trick the compiler into creating an empty cell in our lambda
        cell = None
        raise AssertionError('this route should not be executed')

    return (lambda: cell).__closure__[0]


def _make_skel_func(code, cell_count, base_globals=None):
    """ Creates a skeleton function object that contains just the provided
        code and the correct number of cells in func_closure.  All other
        func attributes (e.g. func_globals) are empty.
    """
    # This is backward-compatibility code: for cloudpickle versions between
    # 0.5.4 and 0.7, base_globals could be a string or None. base_globals
    # should now always be a dictionary.
    if base_globals is None or isinstance(base_globals, str):
        base_globals = {}

    base_globals['__builtins__'] = __builtins__

    closure = (
        tuple(_make_empty_cell() for _ in range(cell_count))
        if cell_count >= 0 else
        None
    )
    return types.FunctionType(code, base_globals, None, None, closure)


def _make_skeleton_class(type_constructor, name, bases, type_kwargs,
                         class_tracker_id, extra):
    """Build dynamic class with an empty __dict__ to be filled once memoized
    If class_tracker_id is not None, try to lookup an existing class definition
    matching that id. If none is found, track a newly reconstructed class
    definition under that id so that other instances stemming from the same
    class id will also reuse this class definition.
    The "extra" variable is meant to be a dict (or None) that can be used for
    forward compatibility shall the need arise.
    """
    skeleton_class = types.new_class(
        name, bases, {'metaclass': type_constructor},
        lambda ns: ns.update(type_kwargs)
    )
    return _lookup_class_or_track(class_tracker_id, skeleton_class)


def _rehydrate_skeleton_class(skeleton_class, class_dict):
    """Put attributes from `class_dict` back on `skeleton_class`.
    See CloudPickler.save_dynamic_class for more info.
    """
    registry = None
    for attrname, attr in class_dict.items():
        if attrname == "_abc_impl":
            registry = attr
        else:
            setattr(skeleton_class, attrname, attr)
    if registry is not None:
        for subclass in registry:
            skeleton_class.register(subclass)

    return skeleton_class


def _make_skeleton_enum(bases, name, qualname, members, module,
                        class_tracker_id, extra):
    """Build dynamic enum with an empty __dict__ to be filled once memoized
    The creation of the enum class is inspired by the code of
    EnumMeta._create_.
    If class_tracker_id is not None, try to lookup an existing enum definition
    matching that id. If none is found, track a newly reconstructed enum
    definition under that id so that other instances stemming from the same
    class id will also reuse this enum definition.
    The "extra" variable is meant to be a dict (or None) that can be used for
    forward compatibility shall the need arise.
    """
    # enums always inherit from their base Enum class at the last position in
    # the list of base classes:
    enum_base = bases[-1]
    metacls = enum_base.__class__
    classdict = metacls.__prepare__(name, bases)

    for member_name, member_value in members.items():
        classdict[member_name] = member_value
    enum_class = metacls.__new__(metacls, name, bases, classdict)
    enum_class.__module__ = module
    enum_class.__qualname__ = qualname

    return _lookup_class_or_track(class_tracker_id, enum_class)


def _is_dynamic(module):
    """
    Return True if the module is special module that cannot be imported by its
    name.
    """
    # Quick check: module that have __file__ attribute are not dynamic modules.
    if hasattr(module, '__file__'):
        return False

    if module.__spec__ is not None:
        return False

    # In PyPy, Some built-in modules such as _codecs can have their
    # __spec__ attribute set to None despite being imported.  For such
    # modules, the ``_find_spec`` utility of the standard library is used.
    parent_name = module.__name__.rpartition('.')[0]
    if parent_name:  # pragma: no cover
        # This code handles the case where an imported package (and not
        # module) remains with __spec__ set to None. It is however untested
        # as no package in the PyPy stdlib has __spec__ set to None after
        # it is imported.
        try:
            parent = sys.modules[parent_name]
        except KeyError:
            msg = "parent {!r} not in sys.modules"
            raise ImportError(msg.format(parent_name))
        else:
            pkgpath = parent.__path__
    else:
        pkgpath = None
    return _find_spec(module.__name__, pkgpath, module) is None


def _make_typevar(name, bound, constraints, covariant, contravariant,
                  class_tracker_id):
    tv = typing.TypeVar(
        name, *constraints, bound=bound,
        covariant=covariant, contravariant=contravariant
    )
    if class_tracker_id is not None:
        return _lookup_class_or_track(class_tracker_id, tv)
    else:  # pragma: nocover
        # Only for Python 3.5.3 compat.
        return tv


def _decompose_typevar(obj):
    try:
        class_tracker_id = _get_or_create_tracker_id(obj)
    except TypeError:  # pragma: nocover
        # TypeVar instances are not weakref-able in Python 3.5.3
        class_tracker_id = None
    return (
        obj.__name__, obj.__bound__, obj.__constraints__,
        obj.__covariant__, obj.__contravariant__,
        class_tracker_id,
    )


def _typevar_reduce(obj):
    # TypeVar instances have no __qualname__ hence we pass the name explicitly.
    module_and_name = _lookup_module_and_qualname(obj, name=obj.__name__)
    if module_and_name is None:
        return (_make_typevar, _decompose_typevar(obj))
    return (getattr, module_and_name)


def _get_bases(typ):
    if hasattr(typ, '__orig_bases__'):
        # For generic types (see PEP 560)
        bases_attr = '__orig_bases__'
    else:
        # For regular class objects
        bases_attr = '__bases__'
    return getattr(typ, bases_attr)
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="heronpy.api.cloudpickle.DEFAULT_PROTOCOL" class="name">var <span class="ident">DEFAULT_PROTOCOL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.DELETE_GLOBAL" class="name">var <span class="ident">DELETE_GLOBAL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.EXTENDED_ARG" class="name">var <span class="ident">EXTENDED_ARG</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.Final" class="name">var <span class="ident">Final</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.GLOBAL_OPS" class="name">var <span class="ident">GLOBAL_OPS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.HAVE_ARGUMENT" class="name">var <span class="ident">HAVE_ARGUMENT</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.LOAD_GLOBAL" class="name">var <span class="ident">LOAD_GLOBAL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.Literal" class="name">var <span class="ident">Literal</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.PYPY" class="name">var <span class="ident">PYPY</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.STORE_GLOBAL" class="name">var <span class="ident">STORE_GLOBAL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.builtin_code_type" class="name">var <span class="ident">builtin_code_type</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.k" class="name">var <span class="ident">k</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="heronpy.api.cloudpickle.v" class="name">var <span class="ident">v</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.cell_set">
    <p>def <span class="ident">cell_set</span>(</p><p>cell, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the value of a closure cell.
The point of this function is to set the cell_contents attribute of a cell
after its creation. This operation is necessary in case the cell contains a
reference to the function the cell belongs to, as when calling the
function's constructor
<code>f = types.FunctionType(code, globals, name, argdefs, closure)</code>,
closure will not be able to contain the yet-to-be-created f.
In Python3.7, cell_contents is writeable, so setting the contents of a cell
can be done simply using</p>
<blockquote>
<blockquote>
<blockquote>
<p>cell.cell_contents = value
In earlier Python3 versions, the cell_contents attribute of a cell is read
only, but this limitation can be worked around by leveraging the Python 3
<code>nonlocal</code> keyword.
In Python2 however, this attribute is read only, and there is no
<code>nonlocal</code> keyword. For this reason, we need to come up with more
complicated hacks to set this attribute.
The chosen approach is to create a function with a STORE_DEREF opcode,
which sets the content of a closure variable. Typically:
def inner(value):
...     lambda: cell  # the lambda makes cell a closure
...     cell = value  # cell is a closure, so this triggers a STORE_DEREF
(Note that in Python2, A STORE_DEREF can never be triggered from an inner
function. The function g for example here
def f(var):
...     def g():
...         var += 1
...     return g
will not modify the closure variable <code>var```inplace, but instead try to
load a local variable var and increment it. As g does not assign the local
variable</code>var<code>any initial value, calling f(1)() will fail at runtime.)
Our objective is to set the value of a given cell</code>cell<code>. So we need to
somewhat reference our</code>cell<code>object into the</code>inner<code>function so that
this object (and not the smoke cell of the lambda function) gets affected
by the STORE_DEREF operation.
In inner,</code>cell<code>is referenced as a cell variable (an enclosing variable
that is referenced by the inner function). If we create a new function
cell_set with the exact same code as</code>inner<code>, but with</code>cell<code>marked as
a free variable instead, the STORE_DEREF will be applied on its closure -</code>cell<code>, which we can specify explicitly during construction! The new
cell_set variable thus actually sets the contents of a specified cell!
Note: we do not make use of the</code>nonlocal`` keyword to set the contents of
a cell in early python3 versions to limit possible syntax errors in case
test and checker libraries decide to parse the whole file.</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.cell_set', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.cell_set" class="source">
    <pre><code>def cell_set(cell, value):
    """Set the value of a closure cell.
    The point of this function is to set the cell_contents attribute of a cell
    after its creation. This operation is necessary in case the cell contains a
    reference to the function the cell belongs to, as when calling the
    function's constructor
    ``f = types.FunctionType(code, globals, name, argdefs, closure)``,
    closure will not be able to contain the yet-to-be-created f.
    In Python3.7, cell_contents is writeable, so setting the contents of a cell
    can be done simply using
    >>> cell.cell_contents = value
    In earlier Python3 versions, the cell_contents attribute of a cell is read
    only, but this limitation can be worked around by leveraging the Python 3
    ``nonlocal`` keyword.
    In Python2 however, this attribute is read only, and there is no
    ``nonlocal`` keyword. For this reason, we need to come up with more
    complicated hacks to set this attribute.
    The chosen approach is to create a function with a STORE_DEREF opcode,
    which sets the content of a closure variable. Typically:
    >>> def inner(value):
    ...     lambda: cell  # the lambda makes cell a closure
    ...     cell = value  # cell is a closure, so this triggers a STORE_DEREF
    (Note that in Python2, A STORE_DEREF can never be triggered from an inner
    function. The function g for example here
    >>> def f(var):
    ...     def g():
    ...         var += 1
    ...     return g
    will not modify the closure variable ``var```inplace, but instead try to
    load a local variable var and increment it. As g does not assign the local
    variable ``var`` any initial value, calling f(1)() will fail at runtime.)
    Our objective is to set the value of a given cell ``cell``. So we need to
    somewhat reference our ``cell`` object into the ``inner`` function so that
    this object (and not the smoke cell of the lambda function) gets affected
    by the STORE_DEREF operation.
    In inner, ``cell`` is referenced as a cell variable (an enclosing variable
    that is referenced by the inner function). If we create a new function
    cell_set with the exact same code as ``inner``, but with ``cell`` marked as
    a free variable instead, the STORE_DEREF will be applied on its closure -
    ``cell``, which we can specify explicitly during construction! The new
    cell_set variable thus actually sets the contents of a specified cell!
    Note: we do not make use of the ``nonlocal`` keyword to set the contents of
    a cell in early python3 versions to limit possible syntax errors in case
    test and checker libraries decide to parse the whole file.
    """

    if sys.version_info[:2] >= (3, 7):  # pragma: no branch
        cell.cell_contents = value
    else:
        _cell_set = types.FunctionType(
            _cell_set_template_code, {}, '_cell_set', (), (cell,),)
        _cell_set(value)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.dump">
    <p>def <span class="ident">dump</span>(</p><p>obj, file, protocol=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Serialize obj as bytes streamed into file
protocol defaults to cloudpickle.DEFAULT_PROTOCOL which is an alias to
pickle.HIGHEST_PROTOCOL. This setting favors maximum communication speed
between processes running the same Python version.
Set protocol=pickle.DEFAULT_PROTOCOL instead if you need to ensure
compatibility with older versions of Python.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.dump', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.dump" class="source">
    <pre><code>def dump(obj, file, protocol=None):
    """Serialize obj as bytes streamed into file
    protocol defaults to cloudpickle.DEFAULT_PROTOCOL which is an alias to
    pickle.HIGHEST_PROTOCOL. This setting favors maximum communication speed
    between processes running the same Python version.
    Set protocol=pickle.DEFAULT_PROTOCOL instead if you need to ensure
    compatibility with older versions of Python.
    """
    CloudPickler(file, protocol=protocol).dump(obj)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.dumps">
    <p>def <span class="ident">dumps</span>(</p><p>obj, protocol=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Serialize obj as a string of bytes allocated in memory
protocol defaults to cloudpickle.DEFAULT_PROTOCOL which is an alias to
pickle.HIGHEST_PROTOCOL. This setting favors maximum communication speed
between processes running the same Python version.
Set protocol=pickle.DEFAULT_PROTOCOL instead if you need to ensure
compatibility with older versions of Python.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.dumps', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.dumps" class="source">
    <pre><code>def dumps(obj, protocol=None):
    """Serialize obj as a string of bytes allocated in memory
    protocol defaults to cloudpickle.DEFAULT_PROTOCOL which is an alias to
    pickle.HIGHEST_PROTOCOL. This setting favors maximum communication speed
    between processes running the same Python version.
    Set protocol=pickle.DEFAULT_PROTOCOL instead if you need to ensure
    compatibility with older versions of Python.
    """
    file = BytesIO()
    try:
        cp = CloudPickler(file, protocol=protocol)
        cp.dump(obj)
        return file.getvalue()
    finally:
        file.close()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.dynamic_subimport">
    <p>def <span class="ident">dynamic_subimport</span>(</p><p>name, vars)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.dynamic_subimport', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.dynamic_subimport" class="source">
    <pre><code>def dynamic_subimport(name, vars):
    mod = types.ModuleType(name)
    mod.__dict__.update(vars)
    mod.__dict__['__builtins__'] = builtins.__dict__
    return mod
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.instance">
    <p>def <span class="ident">instance</span>(</p><p>cls)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a new instance of a class.
Parameters</p>
<hr />
<p>cls : type
    The class to create an instance of.
Returns</p>
<hr />
<p>instance : cls
    A new instance of <code>cls</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.instance', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.instance" class="source">
    <pre><code>def instance(cls):
    """Create a new instance of a class.
    Parameters
    ----------
    cls : type
        The class to create an instance of.
    Returns
    -------
    instance : cls
        A new instance of ``cls``.
    """
    return cls()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.is_tornado_coroutine">
    <p>def <span class="ident">is_tornado_coroutine</span>(</p><p>func)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether <em>func</em> is a Tornado coroutine function.
Running coroutines are not supported.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.is_tornado_coroutine', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.is_tornado_coroutine" class="source">
    <pre><code>def is_tornado_coroutine(func):
    """
    Return whether *func* is a Tornado coroutine function.
    Running coroutines are not supported.
    """
    if 'tornado.gen' not in sys.modules:
        return False
    gen = sys.modules['tornado.gen']
    if not hasattr(gen, "is_coroutine_function"):
        # Tornado version is too old
        return False
    return gen.is_coroutine_function(func)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.load">
    <p>def <span class="ident">load</span>(</p><p>file)</p>
    </div>
    

    
  
    <div class="desc"><p>Read and return an object from the pickle data stored in a file.</p>
<p>This is equivalent to <code>Unpickler(file).load()</code>, but may be more
efficient.</p>
<p>The protocol version of the pickle is detected automatically, so no
protocol argument is needed.  Bytes past the pickled object's
representation are ignored.</p>
<p>The argument <em>file</em> must have two methods, a read() method that takes
an integer argument, and a readline() method that requires no
arguments.  Both methods should return bytes.  Thus <em>file</em> can be a
binary file object opened for reading, an io.BytesIO object, or any
other custom object that meets this interface.</p>
<p>Optional keyword arguments are <em>fix_imports</em>, <em>encoding</em> and <em>errors</em>,
which are used to control compatibility support for pickle stream
generated by Python 2.  If <em>fix_imports</em> is True, pickle will try to
map the old Python 2 names to the new names used in Python 3.  The
<em>encoding</em> and <em>errors</em> tell pickle how to decode 8-bit string
instances pickled by Python 2; these default to 'ASCII' and 'strict',
respectively.  The <em>encoding</em> can be 'bytes' to read these 8-bit
string instances as bytes objects.</p></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.loads">
    <p>def <span class="ident">loads</span>(</p><p>data)</p>
    </div>
    

    
  
    <div class="desc"><p>Read and return an object from the given pickle data.</p>
<p>The protocol version of the pickle is detected automatically, so no
protocol argument is needed.  Bytes past the pickled object's
representation are ignored.</p>
<p>Optional keyword arguments are <em>fix_imports</em>, <em>encoding</em> and <em>errors</em>,
which are used to control compatibility support for pickle stream
generated by Python 2.  If <em>fix_imports</em> is True, pickle will try to
map the old Python 2 names to the new names used in Python 3.  The
<em>encoding</em> and <em>errors</em> tell pickle how to decode 8-bit string
instances pickled by Python 2; these default to 'ASCII' and 'strict',
respectively.  The <em>encoding</em> can be 'bytes' to read these 8-bit
string instances as bytes objects.</p></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.subimport">
    <p>def <span class="ident">subimport</span>(</p><p>name)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.subimport', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.subimport" class="source">
    <pre><code>def subimport(name):
    __import__(name)
    return sys.modules[name]
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="heronpy.api.cloudpickle.CloudPickler" class="name">class <span class="ident">CloudPickler</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler" class="source">
    <pre><code>class CloudPickler(Pickler):

    dispatch = Pickler.dispatch.copy()

    def __init__(self, file, protocol=None):
        if protocol is None:
            protocol = DEFAULT_PROTOCOL
        Pickler.__init__(self, file, protocol=protocol)
        # map ids to dictionary. used to ensure that functions can share global env
        self.globals_ref = {}

    def dump(self, obj):
        self.inject_addons()
        try:
            return Pickler.dump(self, obj)
        except RuntimeError as e:
            if 'recursion' in e.args[0]:
                msg = """Could not pickle object as excessively deep recursion required."""
                raise pickle.PicklingError(msg)
            else:
                raise

    def save_typevar(self, obj):
        self.save_reduce(*_typevar_reduce(obj), obj=obj)

    dispatch[typing.TypeVar] = save_typevar

    def save_memoryview(self, obj):
        self.save(obj.tobytes())

    dispatch[memoryview] = save_memoryview

    def save_module(self, obj):
        """
        Save a module as an import
        """
        if _is_dynamic(obj):
            obj.__dict__.pop('__builtins__', None)
            self.save_reduce(dynamic_subimport, (obj.__name__, vars(obj)),
                             obj=obj)
        else:
            self.save_reduce(subimport, (obj.__name__,), obj=obj)

    dispatch[types.ModuleType] = save_module

    def save_codeobject(self, obj):
        """
        Save a code object
        """
        if hasattr(obj, "co_posonlyargcount"):  # pragma: no branch
            args = (
                obj.co_argcount, obj.co_posonlyargcount,
                obj.co_kwonlyargcount, obj.co_nlocals, obj.co_stacksize,
                obj.co_flags, obj.co_code, obj.co_consts, obj.co_names,
                obj.co_varnames, obj.co_filename, obj.co_name,
                obj.co_firstlineno, obj.co_lnotab, obj.co_freevars,
                obj.co_cellvars
            )
        else:
            args = (
                obj.co_argcount, obj.co_kwonlyargcount, obj.co_nlocals,
                obj.co_stacksize, obj.co_flags, obj.co_code, obj.co_consts,
                obj.co_names, obj.co_varnames, obj.co_filename,
                obj.co_name, obj.co_firstlineno, obj.co_lnotab,
                obj.co_freevars, obj.co_cellvars
            )
        self.save_reduce(types.CodeType, args, obj=obj)

    dispatch[types.CodeType] = save_codeobject

    def save_function(self, obj, name=None):
        """ Registered with the dispatch to handle all function types.
        Determines what kind of function obj is (e.g. lambda, defined at
        interactive prompt, etc) and handles the pickling appropriately.
        """
        if _is_importable_by_name(obj, name=name):
            return Pickler.save_global(self, obj, name=name)
        elif PYPY and isinstance(obj.__code__, builtin_code_type):
            return self.save_pypy_builtin_func(obj)
        else:
            return self.save_function_tuple(obj)

    dispatch[types.FunctionType] = save_function

    def save_pypy_builtin_func(self, obj):
        """Save pypy equivalent of builtin functions.
        PyPy does not have the concept of builtin-functions. Instead,
        builtin-functions are simple function instances, but with a
        builtin-code attribute.
        Most of the time, builtin functions should be pickled by attribute. But
        PyPy has flaky support for __qualname__, so some builtin functions such
        as float.__new__ will be classified as dynamic. For this reason only,
        we created this special routine. Because builtin-functions are not
        expected to have closure or globals, there is no additional hack
        (compared the one already implemented in pickle) to protect ourselves
        from reference cycles. A simple (reconstructor, newargs, obj.__dict__)
        tuple is save_reduced.
        Note also that PyPy improved their support for __qualname__ in v3.6, so
        this routing should be removed when cloudpickle supports only PyPy 3.6
        and later.
        """
        rv = (types.FunctionType, (obj.__code__, {}, obj.__name__,
                                   obj.__defaults__, obj.__closure__),
              obj.__dict__)
        self.save_reduce(*rv, obj=obj)

    def _save_dynamic_enum(self, obj, clsdict):
        """Special handling for dynamic Enum subclasses
        Use a dedicated Enum constructor (inspired by EnumMeta.__call__) as the
        EnumMeta metaclass has complex initialization that makes the Enum
        subclasses hold references to their own instances.
        """
        members = dict((e.name, e.value) for e in obj)

        self.save_reduce(
                _make_skeleton_enum,
                (obj.__bases__, obj.__name__, obj.__qualname__,
                 members, obj.__module__, _get_or_create_tracker_id(obj), None),
                obj=obj
         )

        # Cleanup the clsdict that will be passed to _rehydrate_skeleton_class:
        # Those attributes are already handled by the metaclass.
        for attrname in ["_generate_next_value_", "_member_names_",
                         "_member_map_", "_member_type_",
                         "_value2member_map_"]:
            clsdict.pop(attrname, None)
        for member in members:
            clsdict.pop(member)

    def save_dynamic_class(self, obj):
        """Save a class that can't be stored as module global.
        This method is used to serialize classes that are defined inside
        functions, or that otherwise can't be serialized as attribute lookups
        from global modules.
        """
        clsdict = _extract_class_dict(obj)
        clsdict.pop('__weakref__', None)

        if issubclass(type(obj), abc.ABCMeta):
            # If obj is an instance of an ABCMeta subclass, dont pickle the
            # cache/negative caches populated during isinstance/issubclass
            # checks, but pickle the list of registered subclasses of obj.
            clsdict.pop('_abc_cache', None)
            clsdict.pop('_abc_negative_cache', None)
            clsdict.pop('_abc_negative_cache_version', None)
            registry = clsdict.pop('_abc_registry', None)
            if registry is None:
                # in Python3.7+, the abc caches and registered subclasses of a
                # class are bundled into the single _abc_impl attribute
                clsdict.pop('_abc_impl', None)
                (registry, _, _, _) = abc._get_dump(obj)

                clsdict["_abc_impl"] = [subclass_weakref()
                                        for subclass_weakref in registry]
            else:
                # In the above if clause, registry is a set of weakrefs -- in
                # this case, registry is a WeakSet
                clsdict["_abc_impl"] = [type_ for type_ in registry]

        # On PyPy, __doc__ is a readonly attribute, so we need to include it in
        # the initial skeleton class.  This is safe because we know that the
        # doc can't participate in a cycle with the original class.
        type_kwargs = {'__doc__': clsdict.pop('__doc__', None)}

        if "__slots__" in clsdict:
            type_kwargs['__slots__'] = obj.__slots__
            # pickle string length optimization: member descriptors of obj are
            # created automatically from obj's __slots__ attribute, no need to
            # save them in obj's state
            if isinstance(obj.__slots__, str):
                clsdict.pop(obj.__slots__)
            else:
                for k in obj.__slots__:
                    clsdict.pop(k, None)

        # If type overrides __dict__ as a property, include it in the type
        # kwargs. In Python 2, we can't set this attribute after construction.
        # XXX: can this ever happen in Python 3? If so add a test.
        __dict__ = clsdict.pop('__dict__', None)
        if isinstance(__dict__, property):
            type_kwargs['__dict__'] = __dict__

        save = self.save
        write = self.write

        # We write pickle instructions explicitly here to handle the
        # possibility that the type object participates in a cycle with its own
        # __dict__. We first write an empty "skeleton" version of the class and
        # memoize it before writing the class' __dict__ itself. We then write
        # instructions to "rehydrate" the skeleton class by restoring the
        # attributes from the __dict__.
        #
        # A type can appear in a cycle with its __dict__ if an instance of the
        # type appears in the type's __dict__ (which happens for the stdlib
        # Enum class), or if the type defines methods that close over the name
        # of the type, (which is common for Python 2-style super() calls).

        # Push the rehydration function.
        save(_rehydrate_skeleton_class)

        # Mark the start of the args tuple for the rehydration function.
        write(pickle.MARK)

        # Create and memoize an skeleton class with obj's name and bases.
        if Enum is not None and issubclass(obj, Enum):
            # Special handling of Enum subclasses
            self._save_dynamic_enum(obj, clsdict)
        else:
            # "Regular" class definition:
            tp = type(obj)
            self.save_reduce(_make_skeleton_class,
                             (tp, obj.__name__, _get_bases(obj), type_kwargs,
                              _get_or_create_tracker_id(obj), None),
                             obj=obj)

        # Now save the rest of obj's __dict__. Any references to obj
        # encountered while saving will point to the skeleton class.
        save(clsdict)

        # Write a tuple of (skeleton_class, clsdict).
        write(pickle.TUPLE)

        # Call _rehydrate_skeleton_class(skeleton_class, clsdict)
        write(pickle.REDUCE)

    def save_function_tuple(self, func):
        """  Pickles an actual func object.
        A func comprises: code, globals, defaults, closure, and dict.  We
        extract and save these, injecting reducing functions at certain points
        to recreate the func object.  Keep in mind that some of these pieces
        can contain a ref to the func itself.  Thus, a naive save on these
        pieces could trigger an infinite loop of save's.  To get around that,
        we first create a skeleton func object using just the code (this is
        safe, since this won't contain a ref to the func), and memoize it as
        soon as it's created.  The other stuff can then be filled in later.
        """
        if is_tornado_coroutine(func):
            self.save_reduce(_rebuild_tornado_coroutine, (func.__wrapped__,),
                             obj=func)
            return

        save = self.save
        write = self.write

        code, f_globals, defaults, closure_values, dct, base_globals = self.extract_func_data(func)

        save(_fill_function)  # skeleton function updater
        write(pickle.MARK)    # beginning of tuple that _fill_function expects

        # Extract currently-imported submodules used by func. Storing these
        # modules in a smoke _cloudpickle_subimports attribute of the object's
        # state will trigger the side effect of importing these modules at
        # unpickling time (which is necessary for func to work correctly once
        # depickled)
        submodules = _find_imported_submodules(
            code,
            itertools.chain(f_globals.values(), closure_values or ()),
        )

        # create a skeleton function object and memoize it
        save(_make_skel_func)
        save((
            code,
            len(closure_values) if closure_values is not None else -1,
            base_globals,
        ))
        write(pickle.REDUCE)
        self.memoize(func)

        # save the rest of the func data needed by _fill_function
        state = {
            'globals': f_globals,
            'defaults': defaults,
            'dict': dct,
            'closure_values': closure_values,
            'module': func.__module__,
            'name': func.__name__,
            'doc': func.__doc__,
            '_cloudpickle_submodules': submodules
        }
        if hasattr(func, '__annotations__'):
            state['annotations'] = func.__annotations__
        if hasattr(func, '__qualname__'):
            state['qualname'] = func.__qualname__
        if hasattr(func, '__kwdefaults__'):
            state['kwdefaults'] = func.__kwdefaults__
        save(state)
        write(pickle.TUPLE)
        write(pickle.REDUCE)  # applies _fill_function on the tuple

    def extract_func_data(self, func):
        """
        Turn the function into a tuple of data necessary to recreate it:
            code, globals, defaults, closure_values, dict
        """
        code = func.__code__

        # extract all global ref's
        func_global_refs = _extract_code_globals(code)

        # process all variables referenced by global environment
        f_globals = {}
        for var in func_global_refs:
            if var in func.__globals__:
                f_globals[var] = func.__globals__[var]

        # defaults requires no processing
        defaults = func.__defaults__

        # process closure
        closure = (
            list(map(_get_cell_contents, func.__closure__))
            if func.__closure__ is not None
            else None
        )

        # save the dict
        dct = func.__dict__

        # base_globals represents the future global namespace of func at
        # unpickling time. Looking it up and storing it in globals_ref allow
        # functions sharing the same globals at pickling time to also
        # share them once unpickled, at one condition: since globals_ref is
        # an attribute of a Cloudpickler instance, and that a new CloudPickler is
        # created each time pickle.dump or pickle.dumps is called, functions
        # also need to be saved within the same invokation of
        # cloudpickle.dump/cloudpickle.dumps (for example: cloudpickle.dumps([f1, f2])). There
        # is no such limitation when using Cloudpickler.dump, as long as the
        # multiple invokations are bound to the same Cloudpickler.
        base_globals = self.globals_ref.setdefault(id(func.__globals__), {})

        if base_globals == {}:
            # Add module attributes used to resolve relative imports
            # instructions inside func.
            for k in ["__package__", "__name__", "__path__", "__file__"]:
                # Some built-in functions/methods such as object.__new__  have
                # their __globals__ set to None in PyPy
                if func.__globals__ is not None and k in func.__globals__:
                    base_globals[k] = func.__globals__[k]

        return (code, f_globals, defaults, closure, dct, base_globals)

    def save_getset_descriptor(self, obj):
        return self.save_reduce(getattr, (obj.__objclass__, obj.__name__))

    dispatch[types.GetSetDescriptorType] = save_getset_descriptor

    def save_global(self, obj, name=None, pack=struct.pack):
        """
        Save a "global".
        The name of this method is somewhat misleading: all types get
        dispatched here.
        """
        if obj is type(None):
            return self.save_reduce(type, (None,), obj=obj)
        elif obj is type(Ellipsis):
            return self.save_reduce(type, (Ellipsis,), obj=obj)
        elif obj is type(NotImplemented):
            return self.save_reduce(type, (NotImplemented,), obj=obj)
        elif obj in _BUILTIN_TYPE_NAMES:
            return self.save_reduce(
                _builtin_type, (_BUILTIN_TYPE_NAMES[obj],), obj=obj)

        if sys.version_info[:2] < (3, 7) and _is_parametrized_type_hint(obj):  # noqa  # pragma: no branch
            # Parametrized typing constructs in Python < 3.7 are not compatible
            # with type checks and ``isinstance`` semantics. For this reason,
            # it is easier to detect them using a duck-typing-based check
            # (``_is_parametrized_type_hint``) than to populate the Pickler's
            # dispatch with type-specific savers.
            self._save_parametrized_type_hint(obj)
        elif name is not None:
            Pickler.save_global(self, obj, name=name)
        elif not _is_importable_by_name(obj, name=name):
            self.save_dynamic_class(obj)
        else:
            Pickler.save_global(self, obj, name=name)

    dispatch[type] = save_global

    def save_instancemethod(self, obj):
        # Memoization rarely is ever useful due to python bounding
        if obj.__self__ is None:
            self.save_reduce(getattr, (obj.im_class, obj.__name__))
        else:
            self.save_reduce(types.MethodType, (obj.__func__, obj.__self__), obj=obj)

    dispatch[types.MethodType] = save_instancemethod

    def save_property(self, obj):
        # properties not correctly saved in python
        self.save_reduce(property, (obj.fget, obj.fset, obj.fdel, obj.__doc__),
                         obj=obj)

    dispatch[property] = save_property

    def save_classmethod(self, obj):
        orig_func = obj.__func__
        self.save_reduce(type(obj), (orig_func,), obj=obj)

    dispatch[classmethod] = save_classmethod
    dispatch[staticmethod] = save_classmethod

    def save_itemgetter(self, obj):
        """itemgetter serializer (needed for namedtuple support)"""
        class Dummy:
            def __getitem__(self, item):
                return item
        items = obj(Dummy())
        if not isinstance(items, tuple):
            items = (items,)
        return self.save_reduce(operator.itemgetter, items)

    if type(operator.itemgetter) is type:
        dispatch[operator.itemgetter] = save_itemgetter

    def save_attrgetter(self, obj):
        """attrgetter serializer"""
        class Dummy(object):
            def __init__(self, attrs, index=None):
                self.attrs = attrs
                self.index = index
            def __getattribute__(self, item):
                attrs = object.__getattribute__(self, "attrs")
                index = object.__getattribute__(self, "index")
                if index is None:
                    index = len(attrs)
                    attrs.append(item)
                else:
                    attrs[index] = ".".join([attrs[index], item])
                return type(self)(attrs, index)
        attrs = []
        obj(Dummy(attrs))
        return self.save_reduce(operator.attrgetter, tuple(attrs))

    if type(operator.attrgetter) is type:
        dispatch[operator.attrgetter] = save_attrgetter

    def save_file(self, obj):
        """Save a file"""

        if not hasattr(obj, 'name') or not hasattr(obj, 'mode'):
            raise pickle.PicklingError("Cannot pickle files that do not map to an actual file")
        if obj is sys.stdout:
            return self.save_reduce(getattr, (sys, 'stdout'), obj=obj)
        if obj is sys.stderr:
            return self.save_reduce(getattr, (sys, 'stderr'), obj=obj)
        if obj is sys.stdin:
            raise pickle.PicklingError("Cannot pickle standard input")
        if obj.closed:
            raise pickle.PicklingError("Cannot pickle closed files")
        if hasattr(obj, 'isatty') and obj.isatty():
            raise pickle.PicklingError("Cannot pickle files that map to tty objects")
        if 'r' not in obj.mode and '+' not in obj.mode:
            raise pickle.PicklingError("Cannot pickle files that are not opened for reading: %s" % obj.mode)

        name = obj.name

        # TODO: also support binary mode files with io.BytesIO
        retval = io.StringIO()

        try:
            # Read the whole file
            curloc = obj.tell()
            obj.seek(0)
            contents = obj.read()
            obj.seek(curloc)
        except IOError:
            raise pickle.PicklingError("Cannot pickle file %s as it cannot be read" % name)
        retval.write(contents)
        retval.seek(curloc)

        retval.name = name
        self.save(retval)
        self.memoize(obj)

    def save_ellipsis(self, obj):
        self.save_reduce(_gen_ellipsis, ())

    def save_not_implemented(self, obj):
        self.save_reduce(_gen_not_implemented, ())

    dispatch[io.TextIOWrapper] = save_file
    dispatch[type(Ellipsis)] = save_ellipsis
    dispatch[type(NotImplemented)] = save_not_implemented

    def save_weakset(self, obj):
        self.save_reduce(weakref.WeakSet, (list(obj),))

    dispatch[weakref.WeakSet] = save_weakset

    def save_logger(self, obj):
        self.save_reduce(logging.getLogger, (obj.name,), obj=obj)

    dispatch[logging.Logger] = save_logger

    def save_root_logger(self, obj):
        self.save_reduce(logging.getLogger, (), obj=obj)

    dispatch[logging.RootLogger] = save_root_logger

    if hasattr(types, "MappingProxyType"):  # pragma: no branch
        def save_mappingproxy(self, obj):
            self.save_reduce(types.MappingProxyType, (dict(obj),), obj=obj)

        dispatch[types.MappingProxyType] = save_mappingproxy

    """Special functions for Add-on libraries"""
    def inject_addons(self):
        """Plug in system. Register additional pickling functions if modules already loaded"""
        pass

    if sys.version_info < (3, 7):  # pragma: no branch
        def _save_parametrized_type_hint(self, obj):
            # The distorted type check sematic for typing construct becomes:
            # ``type(obj) is type(TypeHint)``, which means "obj is a
            # parametrized TypeHint"
            if type(obj) is type(Literal):  # pragma: no branch
                initargs = (Literal, obj.__values__)
            elif type(obj) is type(Final):  # pragma: no branch
                initargs = (Final, obj.__type__)
            elif type(obj) is type(ClassVar):
                initargs = (ClassVar, obj.__type__)
            elif type(obj) is type(Generic):
                parameters = obj.__parameters__
                if len(obj.__parameters__) > 0:
                    # in early Python 3.5, __parameters__ was sometimes
                    # preferred to __args__
                    initargs = (obj.__origin__, parameters)
                else:
                    initargs = (obj.__origin__, obj.__args__)
            elif type(obj) is type(Union):
                if sys.version_info < (3, 5, 3):  # pragma: no cover
                    initargs = (Union, obj.__union_params__)
                else:
                    initargs = (Union, obj.__args__)
            elif type(obj) is type(Tuple):
                if sys.version_info < (3, 5, 3):  # pragma: no cover
                    initargs = (Tuple, obj.__tuple_params__)
                else:
                    initargs = (Tuple, obj.__args__)
            elif type(obj) is type(Callable):
                if sys.version_info < (3, 5, 3):  # pragma: no cover
                    args = obj.__args__
                    result = obj.__result__
                    if args != Ellipsis:
                        if isinstance(args, tuple):
                            args = list(args)
                        else:
                            args = [args]
                else:
                    (*args, result) = obj.__args__
                    if len(args) == 1 and args[0] is Ellipsis:
                        args = Ellipsis
                    else:
                        args = list(args)
                initargs = (Callable, (args, result))
            else:  # pragma: no cover
                raise pickle.PicklingError(
                    "Cloudpickle Error: Unknown type {}".format(type(obj))
                )
            self.save_reduce(_create_parametrized_type_hint, initargs, obj=obj)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#heronpy.api.cloudpickle.CloudPickler">CloudPickler</a></li>
          <li>pickle._Pickler</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="heronpy.api.cloudpickle.CloudPickler.dispatch" class="name">var <span class="ident">dispatch</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, file, protocol=None)</p>
    </div>
    

    
  
    <div class="desc"><p>This takes a binary file for writing a pickle data stream.</p>
<p>The optional <em>protocol</em> argument tells the pickler to use the
given protocol; supported protocols are 0, 1, 2, 3 and 4.  The
default protocol is 3; a backward-incompatible protocol designed
for Python 3.</p>
<p>Specifying a negative protocol version selects the highest
protocol version supported.  The higher the protocol used, the
more recent the version of Python needed to read the pickle
produced.</p>
<p>The <em>file</em> argument must have a write() method that accepts a
single bytes argument. It can thus be a file object opened for
binary writing, an io.BytesIO instance, or any other custom
object that meets this interface.</p>
<p>If <em>fix_imports</em> is True and <em>protocol</em> is less than 3, pickle
will try to map the new Python 3 names to the old module names
used in Python 2, so that the pickle data stream is readable
with Python 2.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.__init__', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.__init__" class="source">
    <pre><code>def __init__(self, file, protocol=None):
    if protocol is None:
        protocol = DEFAULT_PROTOCOL
    Pickler.__init__(self, file, protocol=protocol)
    # map ids to dictionary. used to ensure that functions can share global env
    self.globals_ref = {}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.clear_memo">
    <p>def <span class="ident">clear_memo</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Clears the pickler's "memo".</p>
<p>The memo is the data structure that remembers which objects the
pickler has already seen, so that shared or recursive objects
are pickled by reference and not by value.  This method is
useful when re-using picklers.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.clear_memo', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.clear_memo" class="source">
    <pre><code>def clear_memo(self):
    """Clears the pickler's "memo".
    The memo is the data structure that remembers which objects the
    pickler has already seen, so that shared or recursive objects
    are pickled by reference and not by value.  This method is
    useful when re-using picklers.
    """
    self.memo.clear()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.dump">
    <p>def <span class="ident">dump</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Write a pickled representation of obj to the open file.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.dump', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.dump" class="source">
    <pre><code>def dump(self, obj):
    self.inject_addons()
    try:
        return Pickler.dump(self, obj)
    except RuntimeError as e:
        if 'recursion' in e.args[0]:
            msg = """Could not pickle object as excessively deep recursion required."""
            raise pickle.PicklingError(msg)
        else:
            raise
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.extract_func_data">
    <p>def <span class="ident">extract_func_data</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Turn the function into a tuple of data necessary to recreate it:
code, globals, defaults, closure_values, dict</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.extract_func_data', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.extract_func_data" class="source">
    <pre><code>def extract_func_data(self, func):
    """
    Turn the function into a tuple of data necessary to recreate it:
        code, globals, defaults, closure_values, dict
    """
    code = func.__code__
    # extract all global ref's
    func_global_refs = _extract_code_globals(code)
    # process all variables referenced by global environment
    f_globals = {}
    for var in func_global_refs:
        if var in func.__globals__:
            f_globals[var] = func.__globals__[var]
    # defaults requires no processing
    defaults = func.__defaults__
    # process closure
    closure = (
        list(map(_get_cell_contents, func.__closure__))
        if func.__closure__ is not None
        else None
    )
    # save the dict
    dct = func.__dict__
    # base_globals represents the future global namespace of func at
    # unpickling time. Looking it up and storing it in globals_ref allow
    # functions sharing the same globals at pickling time to also
    # share them once unpickled, at one condition: since globals_ref is
    # an attribute of a Cloudpickler instance, and that a new CloudPickler is
    # created each time pickle.dump or pickle.dumps is called, functions
    # also need to be saved within the same invokation of
    # cloudpickle.dump/cloudpickle.dumps (for example: cloudpickle.dumps([f1, f2])). There
    # is no such limitation when using Cloudpickler.dump, as long as the
    # multiple invokations are bound to the same Cloudpickler.
    base_globals = self.globals_ref.setdefault(id(func.__globals__), {})
    if base_globals == {}:
        # Add module attributes used to resolve relative imports
        # instructions inside func.
        for k in ["__package__", "__name__", "__path__", "__file__"]:
            # Some built-in functions/methods such as object.__new__  have
            # their __globals__ set to None in PyPy
            if func.__globals__ is not None and k in func.__globals__:
                base_globals[k] = func.__globals__[k]
    return (code, f_globals, defaults, closure, dct, base_globals)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.get">
    <p>def <span class="ident">get</span>(</p><p>self, i)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.get', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.get" class="source">
    <pre><code>def get(self, i):
    if self.bin:
        if i < 256:
            return BINGET + pack("<B", i)
        else:
            return LONG_BINGET + pack("<I", i)
    return GET + repr(i).encode("ascii") + b'\n'
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.inject_addons">
    <p>def <span class="ident">inject_addons</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Plug in system. Register additional pickling functions if modules already loaded</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.inject_addons', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.inject_addons" class="source">
    <pre><code>def inject_addons(self):
    """Plug in system. Register additional pickling functions if modules already loaded"""
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.memoize">
    <p>def <span class="ident">memoize</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Store an object in the memo.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.memoize', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.memoize" class="source">
    <pre><code>def memoize(self, obj):
    """Store an object in the memo."""
    # The Pickler memo is a dictionary mapping object ids to 2-tuples
    # that contain the Unpickler memo key and the object being memoized.
    # The memo key is written to the pickle and will become
    # the key in the Unpickler's memo.  The object is stored in the
    # Pickler memo so that transient objects are kept alive during
    # pickling.
    # The use of the Unpickler memo length as the memo key is just a
    # convention.  The only requirement is that the memo values be unique.
    # But there appears no advantage to any other scheme, and this
    # scheme allows the Unpickler memo to be implemented as a plain (but
    # growable) array, indexed by memo key.
    if self.fast:
        return
    assert id(obj) not in self.memo
    idx = len(self.memo)
    self.write(self.put(idx))
    self.memo[id(obj)] = idx, obj
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.persistent_id">
    <p>def <span class="ident">persistent_id</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.persistent_id', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.persistent_id" class="source">
    <pre><code>def persistent_id(self, obj):
    # This exists so a subclass can override it
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.put">
    <p>def <span class="ident">put</span>(</p><p>self, idx)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.put', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.put" class="source">
    <pre><code>def put(self, idx):
    if self.proto >= 4:
        return MEMOIZE
    elif self.bin:
        if idx < 256:
            return BINPUT + pack("<B", idx)
        else:
            return LONG_BINPUT + pack("<I", idx)
    else:
        return PUT + repr(idx).encode("ascii") + b'\n'
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save">
    <p>def <span class="ident">save</span>(</p><p>self, obj, save_persistent_id=True)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save" class="source">
    <pre><code>def save(self, obj, save_persistent_id=True):
    self.framer.commit_frame()
    # Check for persistent id (defined by a subclass)
    pid = self.persistent_id(obj)
    if pid is not None and save_persistent_id:
        self.save_pers(pid)
        return
    # Check the memo
    x = self.memo.get(id(obj))
    if x is not None:
        self.write(self.get(x[0]))
        return
    # Check the type dispatch table
    t = type(obj)
    f = self.dispatch.get(t)
    if f is not None:
        f(self, obj) # Call unbound method with explicit self
        return
    # Check private dispatch table if any, or else copyreg.dispatch_table
    reduce = getattr(self, 'dispatch_table', dispatch_table).get(t)
    if reduce is not None:
        rv = reduce(obj)
    else:
        # Check for a class with a custom metaclass; treat as regular class
        try:
            issc = issubclass(t, type)
        except TypeError: # t is not a class (old Boost; see SF #502085)
            issc = False
        if issc:
            self.save_global(obj)
            return
        # Check for a __reduce_ex__ method, fall back to __reduce__
        reduce = getattr(obj, "__reduce_ex__", None)
        if reduce is not None:
            rv = reduce(self.proto)
        else:
            reduce = getattr(obj, "__reduce__", None)
            if reduce is not None:
                rv = reduce()
            else:
                raise PicklingError("Can't pickle %r object: %r" %
                                    (t.__name__, obj))
    # Check for string returned by reduce(), meaning "save as global"
    if isinstance(rv, str):
        self.save_global(obj, rv)
        return
    # Assert that reduce() returned a tuple
    if not isinstance(rv, tuple):
        raise PicklingError("%s must return string or tuple" % reduce)
    # Assert that it returned an appropriately sized tuple
    l = len(rv)
    if not (2 <= l <= 5):
        raise PicklingError("Tuple returned by %s must have "
                            "two to five elements" % reduce)
    # Save the reduce() output and finally memoize the object
    self.save_reduce(obj=obj, *rv)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_attrgetter">
    <p>def <span class="ident">save_attrgetter</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>attrgetter serializer</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_attrgetter', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_attrgetter" class="source">
    <pre><code>def save_attrgetter(self, obj):
    """attrgetter serializer"""
    class Dummy(object):
        def __init__(self, attrs, index=None):
            self.attrs = attrs
            self.index = index
        def __getattribute__(self, item):
            attrs = object.__getattribute__(self, "attrs")
            index = object.__getattribute__(self, "index")
            if index is None:
                index = len(attrs)
                attrs.append(item)
            else:
                attrs[index] = ".".join([attrs[index], item])
            return type(self)(attrs, index)
    attrs = []
    obj(Dummy(attrs))
    return self.save_reduce(operator.attrgetter, tuple(attrs))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_bool">
    <p>def <span class="ident">save_bool</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_bool', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_bool" class="source">
    <pre><code>def save_bool(self, obj):
    if self.proto >= 2:
        self.write(NEWTRUE if obj else NEWFALSE)
    else:
        self.write(TRUE if obj else FALSE)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_bytes">
    <p>def <span class="ident">save_bytes</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_bytes', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_bytes" class="source">
    <pre><code>def save_bytes(self, obj):
    if self.proto < 3:
        if not obj: # bytes object is empty
            self.save_reduce(bytes, (), obj=obj)
        else:
            self.save_reduce(codecs.encode,
                             (str(obj, 'latin1'), 'latin1'), obj=obj)
        return
    n = len(obj)
    if n <= 0xff:
        self.write(SHORT_BINBYTES + pack("<B", n) + obj)
    elif n > 0xffffffff and self.proto >= 4:
        self.write(BINBYTES8 + pack("<Q", n) + obj)
    else:
        self.write(BINBYTES + pack("<I", n) + obj)
    self.memoize(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_classmethod">
    <p>def <span class="ident">save_classmethod</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_classmethod', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_classmethod" class="source">
    <pre><code>def save_classmethod(self, obj):
    orig_func = obj.__func__
    self.save_reduce(type(obj), (orig_func,), obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_codeobject">
    <p>def <span class="ident">save_codeobject</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Save a code object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_codeobject', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_codeobject" class="source">
    <pre><code>def save_codeobject(self, obj):
    """
    Save a code object
    """
    if hasattr(obj, "co_posonlyargcount"):  # pragma: no branch
        args = (
            obj.co_argcount, obj.co_posonlyargcount,
            obj.co_kwonlyargcount, obj.co_nlocals, obj.co_stacksize,
            obj.co_flags, obj.co_code, obj.co_consts, obj.co_names,
            obj.co_varnames, obj.co_filename, obj.co_name,
            obj.co_firstlineno, obj.co_lnotab, obj.co_freevars,
            obj.co_cellvars
        )
    else:
        args = (
            obj.co_argcount, obj.co_kwonlyargcount, obj.co_nlocals,
            obj.co_stacksize, obj.co_flags, obj.co_code, obj.co_consts,
            obj.co_names, obj.co_varnames, obj.co_filename,
            obj.co_name, obj.co_firstlineno, obj.co_lnotab,
            obj.co_freevars, obj.co_cellvars
        )
    self.save_reduce(types.CodeType, args, obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_dict">
    <p>def <span class="ident">save_dict</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_dict', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_dict" class="source">
    <pre><code>def save_dict(self, obj):
    if self.bin:
        self.write(EMPTY_DICT)
    else:   # proto 0 -- can't use EMPTY_DICT
        self.write(MARK + DICT)
    self.memoize(obj)
    self._batch_setitems(obj.items())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_dynamic_class">
    <p>def <span class="ident">save_dynamic_class</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Save a class that can't be stored as module global.
This method is used to serialize classes that are defined inside
functions, or that otherwise can't be serialized as attribute lookups
from global modules.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_dynamic_class', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_dynamic_class" class="source">
    <pre><code>def save_dynamic_class(self, obj):
    """Save a class that can't be stored as module global.
    This method is used to serialize classes that are defined inside
    functions, or that otherwise can't be serialized as attribute lookups
    from global modules.
    """
    clsdict = _extract_class_dict(obj)
    clsdict.pop('__weakref__', None)
    if issubclass(type(obj), abc.ABCMeta):
        # If obj is an instance of an ABCMeta subclass, dont pickle the
        # cache/negative caches populated during isinstance/issubclass
        # checks, but pickle the list of registered subclasses of obj.
        clsdict.pop('_abc_cache', None)
        clsdict.pop('_abc_negative_cache', None)
        clsdict.pop('_abc_negative_cache_version', None)
        registry = clsdict.pop('_abc_registry', None)
        if registry is None:
            # in Python3.7+, the abc caches and registered subclasses of a
            # class are bundled into the single _abc_impl attribute
            clsdict.pop('_abc_impl', None)
            (registry, _, _, _) = abc._get_dump(obj)
            clsdict["_abc_impl"] = [subclass_weakref()
                                    for subclass_weakref in registry]
        else:
            # In the above if clause, registry is a set of weakrefs -- in
            # this case, registry is a WeakSet
            clsdict["_abc_impl"] = [type_ for type_ in registry]
    # On PyPy, __doc__ is a readonly attribute, so we need to include it in
    # the initial skeleton class.  This is safe because we know that the
    # doc can't participate in a cycle with the original class.
    type_kwargs = {'__doc__': clsdict.pop('__doc__', None)}
    if "__slots__" in clsdict:
        type_kwargs['__slots__'] = obj.__slots__
        # pickle string length optimization: member descriptors of obj are
        # created automatically from obj's __slots__ attribute, no need to
        # save them in obj's state
        if isinstance(obj.__slots__, str):
            clsdict.pop(obj.__slots__)
        else:
            for k in obj.__slots__:
                clsdict.pop(k, None)
    # If type overrides __dict__ as a property, include it in the type
    # kwargs. In Python 2, we can't set this attribute after construction.
    # XXX: can this ever happen in Python 3? If so add a test.
    __dict__ = clsdict.pop('__dict__', None)
    if isinstance(__dict__, property):
        type_kwargs['__dict__'] = __dict__
    save = self.save
    write = self.write
    # We write pickle instructions explicitly here to handle the
    # possibility that the type object participates in a cycle with its own
    # __dict__. We first write an empty "skeleton" version of the class and
    # memoize it before writing the class' __dict__ itself. We then write
    # instructions to "rehydrate" the skeleton class by restoring the
    # attributes from the __dict__.
    #
    # A type can appear in a cycle with its __dict__ if an instance of the
    # type appears in the type's __dict__ (which happens for the stdlib
    # Enum class), or if the type defines methods that close over the name
    # of the type, (which is common for Python 2-style super() calls).
    # Push the rehydration function.
    save(_rehydrate_skeleton_class)
    # Mark the start of the args tuple for the rehydration function.
    write(pickle.MARK)
    # Create and memoize an skeleton class with obj's name and bases.
    if Enum is not None and issubclass(obj, Enum):
        # Special handling of Enum subclasses
        self._save_dynamic_enum(obj, clsdict)
    else:
        # "Regular" class definition:
        tp = type(obj)
        self.save_reduce(_make_skeleton_class,
                         (tp, obj.__name__, _get_bases(obj), type_kwargs,
                          _get_or_create_tracker_id(obj), None),
                         obj=obj)
    # Now save the rest of obj's __dict__. Any references to obj
    # encountered while saving will point to the skeleton class.
    save(clsdict)
    # Write a tuple of (skeleton_class, clsdict).
    write(pickle.TUPLE)
    # Call _rehydrate_skeleton_class(skeleton_class, clsdict)
    write(pickle.REDUCE)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_ellipsis">
    <p>def <span class="ident">save_ellipsis</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_ellipsis', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_ellipsis" class="source">
    <pre><code>def save_ellipsis(self, obj):
    self.save_reduce(_gen_ellipsis, ())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_file">
    <p>def <span class="ident">save_file</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Save a file</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_file', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_file" class="source">
    <pre><code>def save_file(self, obj):
    """Save a file"""
    if not hasattr(obj, 'name') or not hasattr(obj, 'mode'):
        raise pickle.PicklingError("Cannot pickle files that do not map to an actual file")
    if obj is sys.stdout:
        return self.save_reduce(getattr, (sys, 'stdout'), obj=obj)
    if obj is sys.stderr:
        return self.save_reduce(getattr, (sys, 'stderr'), obj=obj)
    if obj is sys.stdin:
        raise pickle.PicklingError("Cannot pickle standard input")
    if obj.closed:
        raise pickle.PicklingError("Cannot pickle closed files")
    if hasattr(obj, 'isatty') and obj.isatty():
        raise pickle.PicklingError("Cannot pickle files that map to tty objects")
    if 'r' not in obj.mode and '+' not in obj.mode:
        raise pickle.PicklingError("Cannot pickle files that are not opened for reading: %s" % obj.mode)
    name = obj.name
    # TODO: also support binary mode files with io.BytesIO
    retval = io.StringIO()
    try:
        # Read the whole file
        curloc = obj.tell()
        obj.seek(0)
        contents = obj.read()
        obj.seek(curloc)
    except IOError:
        raise pickle.PicklingError("Cannot pickle file %s as it cannot be read" % name)
    retval.write(contents)
    retval.seek(curloc)
    retval.name = name
    self.save(retval)
    self.memoize(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_float">
    <p>def <span class="ident">save_float</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_float', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_float" class="source">
    <pre><code>def save_float(self, obj):
    if self.bin:
        self.write(BINFLOAT + pack('>d', obj))
    else:
        self.write(FLOAT + repr(obj).encode("ascii") + b'\n')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_frozenset">
    <p>def <span class="ident">save_frozenset</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_frozenset', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_frozenset" class="source">
    <pre><code>def save_frozenset(self, obj):
    save = self.save
    write = self.write
    if self.proto < 4:
        self.save_reduce(frozenset, (list(obj),), obj=obj)
        return
    write(MARK)
    for item in obj:
        save(item)
    if id(obj) in self.memo:
        # If the object is already in the memo, this means it is
        # recursive. In this case, throw away everything we put on the
        # stack, and fetch the object back from the memo.
        write(POP_MARK + self.get(self.memo[id(obj)][0]))
        return
    write(FROZENSET)
    self.memoize(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_function">
    <p>def <span class="ident">save_function</span>(</p><p>self, obj, name=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Registered with the dispatch to handle all function types.
Determines what kind of function obj is (e.g. lambda, defined at
interactive prompt, etc) and handles the pickling appropriately.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_function', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_function" class="source">
    <pre><code>def save_function(self, obj, name=None):
    """ Registered with the dispatch to handle all function types.
    Determines what kind of function obj is (e.g. lambda, defined at
    interactive prompt, etc) and handles the pickling appropriately.
    """
    if _is_importable_by_name(obj, name=name):
        return Pickler.save_global(self, obj, name=name)
    elif PYPY and isinstance(obj.__code__, builtin_code_type):
        return self.save_pypy_builtin_func(obj)
    else:
        return self.save_function_tuple(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_function_tuple">
    <p>def <span class="ident">save_function_tuple</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickles an actual func object.
A func comprises: code, globals, defaults, closure, and dict.  We
extract and save these, injecting reducing functions at certain points
to recreate the func object.  Keep in mind that some of these pieces
can contain a ref to the func itself.  Thus, a naive save on these
pieces could trigger an infinite loop of save's.  To get around that,
we first create a skeleton func object using just the code (this is
safe, since this won't contain a ref to the func), and memoize it as
soon as it's created.  The other stuff can then be filled in later.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_function_tuple', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_function_tuple" class="source">
    <pre><code>def save_function_tuple(self, func):
    """  Pickles an actual func object.
    A func comprises: code, globals, defaults, closure, and dict.  We
    extract and save these, injecting reducing functions at certain points
    to recreate the func object.  Keep in mind that some of these pieces
    can contain a ref to the func itself.  Thus, a naive save on these
    pieces could trigger an infinite loop of save's.  To get around that,
    we first create a skeleton func object using just the code (this is
    safe, since this won't contain a ref to the func), and memoize it as
    soon as it's created.  The other stuff can then be filled in later.
    """
    if is_tornado_coroutine(func):
        self.save_reduce(_rebuild_tornado_coroutine, (func.__wrapped__,),
                         obj=func)
        return
    save = self.save
    write = self.write
    code, f_globals, defaults, closure_values, dct, base_globals = self.extract_func_data(func)
    save(_fill_function)  # skeleton function updater
    write(pickle.MARK)    # beginning of tuple that _fill_function expects
    # Extract currently-imported submodules used by func. Storing these
    # modules in a smoke _cloudpickle_subimports attribute of the object's
    # state will trigger the side effect of importing these modules at
    # unpickling time (which is necessary for func to work correctly once
    # depickled)
    submodules = _find_imported_submodules(
        code,
        itertools.chain(f_globals.values(), closure_values or ()),
    )
    # create a skeleton function object and memoize it
    save(_make_skel_func)
    save((
        code,
        len(closure_values) if closure_values is not None else -1,
        base_globals,
    ))
    write(pickle.REDUCE)
    self.memoize(func)
    # save the rest of the func data needed by _fill_function
    state = {
        'globals': f_globals,
        'defaults': defaults,
        'dict': dct,
        'closure_values': closure_values,
        'module': func.__module__,
        'name': func.__name__,
        'doc': func.__doc__,
        '_cloudpickle_submodules': submodules
    }
    if hasattr(func, '__annotations__'):
        state['annotations'] = func.__annotations__
    if hasattr(func, '__qualname__'):
        state['qualname'] = func.__qualname__
    if hasattr(func, '__kwdefaults__'):
        state['kwdefaults'] = func.__kwdefaults__
    save(state)
    write(pickle.TUPLE)
    write(pickle.REDUCE)  # applies _fill_function on the tuple
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_getset_descriptor">
    <p>def <span class="ident">save_getset_descriptor</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_getset_descriptor', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_getset_descriptor" class="source">
    <pre><code>def save_getset_descriptor(self, obj):
    return self.save_reduce(getattr, (obj.__objclass__, obj.__name__))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_global">
    <p>def <span class="ident">save_global</span>(</p><p>self, obj, name=None, pack=&lt;built-in function pack&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Save a "global".
The name of this method is somewhat misleading: all types get
dispatched here.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_global', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_global" class="source">
    <pre><code>def save_global(self, obj, name=None, pack=struct.pack):
    """
    Save a "global".
    The name of this method is somewhat misleading: all types get
    dispatched here.
    """
    if obj is type(None):
        return self.save_reduce(type, (None,), obj=obj)
    elif obj is type(Ellipsis):
        return self.save_reduce(type, (Ellipsis,), obj=obj)
    elif obj is type(NotImplemented):
        return self.save_reduce(type, (NotImplemented,), obj=obj)
    elif obj in _BUILTIN_TYPE_NAMES:
        return self.save_reduce(
            _builtin_type, (_BUILTIN_TYPE_NAMES[obj],), obj=obj)
    if sys.version_info[:2] < (3, 7) and _is_parametrized_type_hint(obj):  # noqa  # pragma: no branch
        # Parametrized typing constructs in Python < 3.7 are not compatible
        # with type checks and ``isinstance`` semantics. For this reason,
        # it is easier to detect them using a duck-typing-based check
        # (``_is_parametrized_type_hint``) than to populate the Pickler's
        # dispatch with type-specific savers.
        self._save_parametrized_type_hint(obj)
    elif name is not None:
        Pickler.save_global(self, obj, name=name)
    elif not _is_importable_by_name(obj, name=name):
        self.save_dynamic_class(obj)
    else:
        Pickler.save_global(self, obj, name=name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_instancemethod">
    <p>def <span class="ident">save_instancemethod</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_instancemethod', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_instancemethod" class="source">
    <pre><code>def save_instancemethod(self, obj):
    # Memoization rarely is ever useful due to python bounding
    if obj.__self__ is None:
        self.save_reduce(getattr, (obj.im_class, obj.__name__))
    else:
        self.save_reduce(types.MethodType, (obj.__func__, obj.__self__), obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_itemgetter">
    <p>def <span class="ident">save_itemgetter</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>itemgetter serializer (needed for namedtuple support)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_itemgetter', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_itemgetter" class="source">
    <pre><code>def save_itemgetter(self, obj):
    """itemgetter serializer (needed for namedtuple support)"""
    class Dummy:
        def __getitem__(self, item):
            return item
    items = obj(Dummy())
    if not isinstance(items, tuple):
        items = (items,)
    return self.save_reduce(operator.itemgetter, items)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_list">
    <p>def <span class="ident">save_list</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_list', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_list" class="source">
    <pre><code>def save_list(self, obj):
    if self.bin:
        self.write(EMPTY_LIST)
    else:   # proto 0 -- can't use EMPTY_LIST
        self.write(MARK + LIST)
    self.memoize(obj)
    self._batch_appends(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_logger">
    <p>def <span class="ident">save_logger</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_logger', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_logger" class="source">
    <pre><code>def save_logger(self, obj):
    self.save_reduce(logging.getLogger, (obj.name,), obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_long">
    <p>def <span class="ident">save_long</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_long', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_long" class="source">
    <pre><code>def save_long(self, obj):
    if self.bin:
        # If the int is small enough to fit in a signed 4-byte 2's-comp
        # format, we can store it more efficiently than the general
        # case.
        # First one- and two-byte unsigned ints:
        if obj >= 0:
            if obj <= 0xff:
                self.write(BININT1 + pack("<B", obj))
                return
            if obj <= 0xffff:
                self.write(BININT2 + pack("<H", obj))
                return
        # Next check for 4-byte signed ints:
        if -0x80000000 <= obj <= 0x7fffffff:
            self.write(BININT + pack("<i", obj))
            return
    if self.proto >= 2:
        encoded = encode_long(obj)
        n = len(encoded)
        if n < 256:
            self.write(LONG1 + pack("<B", n) + encoded)
        else:
            self.write(LONG4 + pack("<i", n) + encoded)
        return
    self.write(LONG + repr(obj).encode("ascii") + b'L\n')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_mappingproxy">
    <p>def <span class="ident">save_mappingproxy</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_mappingproxy', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_mappingproxy" class="source">
    <pre><code>def save_mappingproxy(self, obj):
    self.save_reduce(types.MappingProxyType, (dict(obj),), obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_memoryview">
    <p>def <span class="ident">save_memoryview</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_memoryview', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_memoryview" class="source">
    <pre><code>def save_memoryview(self, obj):
    self.save(obj.tobytes())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_module">
    <p>def <span class="ident">save_module</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Save a module as an import</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_module', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_module" class="source">
    <pre><code>def save_module(self, obj):
    """
    Save a module as an import
    """
    if _is_dynamic(obj):
        obj.__dict__.pop('__builtins__', None)
        self.save_reduce(dynamic_subimport, (obj.__name__, vars(obj)),
                         obj=obj)
    else:
        self.save_reduce(subimport, (obj.__name__,), obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_none">
    <p>def <span class="ident">save_none</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_none', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_none" class="source">
    <pre><code>def save_none(self, obj):
    self.write(NONE)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_not_implemented">
    <p>def <span class="ident">save_not_implemented</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_not_implemented', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_not_implemented" class="source">
    <pre><code>def save_not_implemented(self, obj):
    self.save_reduce(_gen_not_implemented, ())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_pers">
    <p>def <span class="ident">save_pers</span>(</p><p>self, pid)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_pers', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_pers" class="source">
    <pre><code>def save_pers(self, pid):
    # Save a persistent id reference
    if self.bin:
        self.save(pid, save_persistent_id=False)
        self.write(BINPERSID)
    else:
        try:
            self.write(PERSID + str(pid).encode("ascii") + b'\n')
        except UnicodeEncodeError:
            raise PicklingError(
                "persistent IDs in protocol 0 must be ASCII strings")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_property">
    <p>def <span class="ident">save_property</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_property', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_property" class="source">
    <pre><code>def save_property(self, obj):
    # properties not correctly saved in python
    self.save_reduce(property, (obj.fget, obj.fset, obj.fdel, obj.__doc__),
                     obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_pypy_builtin_func">
    <p>def <span class="ident">save_pypy_builtin_func</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Save pypy equivalent of builtin functions.
PyPy does not have the concept of builtin-functions. Instead,
builtin-functions are simple function instances, but with a
builtin-code attribute.
Most of the time, builtin functions should be pickled by attribute. But
PyPy has flaky support for <strong>qualname</strong>, so some builtin functions such
as float.<strong>new</strong> will be classified as dynamic. For this reason only,
we created this special routine. Because builtin-functions are not
expected to have closure or globals, there is no additional hack
(compared the one already implemented in pickle) to protect ourselves
from reference cycles. A simple (reconstructor, newargs, obj.<strong>dict</strong>)
tuple is save_reduced.
Note also that PyPy improved their support for <strong>qualname</strong> in v3.6, so
this routing should be removed when cloudpickle supports only PyPy 3.6
and later.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_pypy_builtin_func', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_pypy_builtin_func" class="source">
    <pre><code>def save_pypy_builtin_func(self, obj):
    """Save pypy equivalent of builtin functions.
    PyPy does not have the concept of builtin-functions. Instead,
    builtin-functions are simple function instances, but with a
    builtin-code attribute.
    Most of the time, builtin functions should be pickled by attribute. But
    PyPy has flaky support for __qualname__, so some builtin functions such
    as float.__new__ will be classified as dynamic. For this reason only,
    we created this special routine. Because builtin-functions are not
    expected to have closure or globals, there is no additional hack
    (compared the one already implemented in pickle) to protect ourselves
    from reference cycles. A simple (reconstructor, newargs, obj.__dict__)
    tuple is save_reduced.
    Note also that PyPy improved their support for __qualname__ in v3.6, so
    this routing should be removed when cloudpickle supports only PyPy 3.6
    and later.
    """
    rv = (types.FunctionType, (obj.__code__, {}, obj.__name__,
                               obj.__defaults__, obj.__closure__),
          obj.__dict__)
    self.save_reduce(*rv, obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_reduce">
    <p>def <span class="ident">save_reduce</span>(</p><p>self, func, args, state=None, listitems=None, dictitems=None, obj=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_reduce', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_reduce" class="source">
    <pre><code>def save_reduce(self, func, args, state=None, listitems=None,
                dictitems=None, obj=None):
    # This API is called by some subclasses
    if not isinstance(args, tuple):
        raise PicklingError("args from save_reduce() must be a tuple")
    if not callable(func):
        raise PicklingError("func from save_reduce() must be callable")
    save = self.save
    write = self.write
    func_name = getattr(func, "__name__", "")
    if self.proto >= 2 and func_name == "__newobj_ex__":
        cls, args, kwargs = args
        if not hasattr(cls, "__new__"):
            raise PicklingError("args[0] from {} args has no __new__"
                                .format(func_name))
        if obj is not None and cls is not obj.__class__:
            raise PicklingError("args[0] from {} args has the wrong class"
                                .format(func_name))
        if self.proto >= 4:
            save(cls)
            save(args)
            save(kwargs)
            write(NEWOBJ_EX)
        else:
            func = partial(cls.__new__, cls, *args, **kwargs)
            save(func)
            save(())
            write(REDUCE)
    elif self.proto >= 2 and func_name == "__newobj__":
        # A __reduce__ implementation can direct protocol 2 or newer to
        # use the more efficient NEWOBJ opcode, while still
        # allowing protocol 0 and 1 to work normally.  For this to
        # work, the function returned by __reduce__ should be
        # called __newobj__, and its first argument should be a
        # class.  The implementation for __newobj__
        # should be as follows, although pickle has no way to
        # verify this:
        #
        # def __newobj__(cls, *args):
        #     return cls.__new__(cls, *args)
        #
        # Protocols 0 and 1 will pickle a reference to __newobj__,
        # while protocol 2 (and above) will pickle a reference to
        # cls, the remaining args tuple, and the NEWOBJ code,
        # which calls cls.__new__(cls, *args) at unpickling time
        # (see load_newobj below).  If __reduce__ returns a
        # three-tuple, the state from the third tuple item will be
        # pickled regardless of the protocol, calling __setstate__
        # at unpickling time (see load_build below).
        #
        # Note that no standard __newobj__ implementation exists;
        # you have to provide your own.  This is to enforce
        # compatibility with Python 2.2 (pickles written using
        # protocol 0 or 1 in Python 2.3 should be unpicklable by
        # Python 2.2).
        cls = args[0]
        if not hasattr(cls, "__new__"):
            raise PicklingError(
                "args[0] from __newobj__ args has no __new__")
        if obj is not None and cls is not obj.__class__:
            raise PicklingError(
                "args[0] from __newobj__ args has the wrong class")
        args = args[1:]
        save(cls)
        save(args)
        write(NEWOBJ)
    else:
        save(func)
        save(args)
        write(REDUCE)
    if obj is not None:
        # If the object is already in the memo, this means it is
        # recursive. In this case, throw away everything we put on the
        # stack, and fetch the object back from the memo.
        if id(obj) in self.memo:
            write(POP + self.get(self.memo[id(obj)][0]))
        else:
            self.memoize(obj)
    # More new special cases (that work with older protocols as
    # well): when __reduce__ returns a tuple with 4 or 5 items,
    # the 4th and 5th item should be iterators that provide list
    # items and dict items (as (key, value) tuples), or None.
    if listitems is not None:
        self._batch_appends(listitems)
    if dictitems is not None:
        self._batch_setitems(dictitems)
    if state is not None:
        save(state)
        write(BUILD)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_root_logger">
    <p>def <span class="ident">save_root_logger</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_root_logger', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_root_logger" class="source">
    <pre><code>def save_root_logger(self, obj):
    self.save_reduce(logging.getLogger, (), obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_set">
    <p>def <span class="ident">save_set</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_set', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_set" class="source">
    <pre><code>def save_set(self, obj):
    save = self.save
    write = self.write
    if self.proto < 4:
        self.save_reduce(set, (list(obj),), obj=obj)
        return
    write(EMPTY_SET)
    self.memoize(obj)
    it = iter(obj)
    while True:
        batch = list(islice(it, self._BATCHSIZE))
        n = len(batch)
        if n > 0:
            write(MARK)
            for item in batch:
                save(item)
            write(ADDITEMS)
        if n < self._BATCHSIZE:
            return
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_str">
    <p>def <span class="ident">save_str</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_str', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_str" class="source">
    <pre><code>def save_str(self, obj):
    if self.bin:
        encoded = obj.encode('utf-8', 'surrogatepass')
        n = len(encoded)
        if n <= 0xff and self.proto >= 4:
            self.write(SHORT_BINUNICODE + pack("<B", n) + encoded)
        elif n > 0xffffffff and self.proto >= 4:
            self.write(BINUNICODE8 + pack("<Q", n) + encoded)
        else:
            self.write(BINUNICODE + pack("<I", n) + encoded)
    else:
        obj = obj.replace("\\", "\\u005c")
        obj = obj.replace("\n", "\\u000a")
        self.write(UNICODE + obj.encode('raw-unicode-escape') +
                   b'\n')
    self.memoize(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_tuple">
    <p>def <span class="ident">save_tuple</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_tuple', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_tuple" class="source">
    <pre><code>def save_tuple(self, obj):
    if not obj: # tuple is empty
        if self.bin:
            self.write(EMPTY_TUPLE)
        else:
            self.write(MARK + TUPLE)
        return
    n = len(obj)
    save = self.save
    memo = self.memo
    if n <= 3 and self.proto >= 2:
        for element in obj:
            save(element)
        # Subtle.  Same as in the big comment below.
        if id(obj) in memo:
            get = self.get(memo[id(obj)][0])
            self.write(POP * n + get)
        else:
            self.write(_tuplesize2code[n])
            self.memoize(obj)
        return
    # proto 0 or proto 1 and tuple isn't empty, or proto > 1 and tuple
    # has more than 3 elements.
    write = self.write
    write(MARK)
    for element in obj:
        save(element)
    if id(obj) in memo:
        # Subtle.  d was not in memo when we entered save_tuple(), so
        # the process of saving the tuple's elements must have saved
        # the tuple itself:  the tuple is recursive.  The proper action
        # now is to throw away everything we put on the stack, and
        # simply GET the tuple (it's already constructed).  This check
        # could have been done in the "for element" loop instead, but
        # recursive tuples are a rare thing.
        get = self.get(memo[id(obj)][0])
        if self.bin:
            write(POP_MARK + get)
        else:   # proto 0 -- POP_MARK not available
            write(POP * (n+1) + get)
        return
    # No recursion.
    write(TUPLE)
    self.memoize(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_type">
    <p>def <span class="ident">save_type</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_type', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_type" class="source">
    <pre><code>def save_type(self, obj):
    if obj is type(None):
        return self.save_reduce(type, (None,), obj=obj)
    elif obj is type(NotImplemented):
        return self.save_reduce(type, (NotImplemented,), obj=obj)
    elif obj is type(...):
        return self.save_reduce(type, (...,), obj=obj)
    return self.save_global(obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_typevar">
    <p>def <span class="ident">save_typevar</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_typevar', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_typevar" class="source">
    <pre><code>def save_typevar(self, obj):
    self.save_reduce(*_typevar_reduce(obj), obj=obj)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="heronpy.api.cloudpickle.CloudPickler.save_weakset">
    <p>def <span class="ident">save_weakset</span>(</p><p>self, obj)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-heronpy.api.cloudpickle.CloudPickler.save_weakset', this);">Show source &equiv;</a></p>
  <div id="source-heronpy.api.cloudpickle.CloudPickler.save_weakset" class="source">
    <pre><code>def save_weakset(self, obj):
    self.save_reduce(weakref.WeakSet, (list(obj),))
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="heronpy.api.cloudpickle.CloudPickler.globals_ref" class="name">var <span class="ident">globals_ref</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
